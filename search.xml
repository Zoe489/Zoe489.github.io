<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript-setTimeOut()与setInterval()]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-setTimeOut-setInterval%2F</url>
    <content type="text"><![CDATA[Javascript用来处理延时和定时任务的setTimeOut和setInterval函数应用非常广泛，它们都用来处理延时和定时任务，比如打开网页一段时间后弹出一个登录框，页面每隔一段时间发送异步请求获取最新数据等等。 setTimeOut() setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式 setTimeout()只执行一次 第一个参数是要执行的code或句柄，第二个是延迟的毫秒数。 用法 1var timeoutID = window.setTimeout(func, [delay, param1, param2, ...]); var timeoutID = window.setTimeout(code, [delay]); clearTimeOut()函数用来清除定时器 实例 12345for(var i=1;i&lt;=3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0);&#125;; 输出4，4，4原因：Javascript事件处理器在线程空闲之前不会运行。那么问题来了，如何让上述代码输出1 2 3？12345for(var i=1;i&lt;=3;i++)&#123; setTimeout((function(a)&#123; //改成立即执行函数 console.log(a); &#125;)(i),0);&#125;; setInterval() setInterval()是在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval()把它清除 第一个参数是要执行的code或句柄，第二个是延迟的毫秒数。 写一个递归，每隔5秒调用自身，一共100次。12345678var counter = 0;var timer = setInterval(function() &#123; alert('test'); counter++; if(counter == 100) &#123; clearInterval(timer); &#125;&#125;,5000);]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>setTimeout(); setInterval()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-基本数据类型]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-DataType%2F</url>
    <content type="text"><![CDATA[六种基本数据类型 undefined: 一个未初始化的变量的值为undefined; 一个没有传入实参的形参变量的值为undefined; 如果一个函数什么都不返回,则该函数默认返回undefined; null: 没有对象被呈现 string: boolean: number: sysbol(ES6): null与undefined的不同点 null是一个字面量（而不是全局对象的一个属性,undefined 是）; null是一个表示”无”的对象, Number(null) == 0；undefined是一个表示”无”的原始值, Number(undefined) == NaN。 当声明的变量还未被初始化时,变量的默认值为undefined。 null用来表示尚未存在的对象,常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义。典型用法是： （1）变量被声明了,但没有赋值时,就等于undefined。（2） 调用函数时,应该提供的参数没有提供,该参数等于undefined。 （3）函数没有返回值时,默认返回undefined。 （4）对象没有赋值的属性,该属性的值为undefined。 null表示”没有对象”,即该处不应该有值。典型用法是： （1） 作为函数的参数,表示该函数的参数不是对象。 （2） 作为对象原型链的终点。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>undefined, null</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-localsearch本地搜索]]></title>
    <url>%2F2017%2F08%2F07%2Fhexo-localsearch%2F</url>
    <content type="text"><![CDATA[在git bash上输入npm install hexo-generate-search –save 再安装npm install hexo-generate-searchdb –save 在主题目录下的配置文件_config.yml中修改1234567local_search: enable: true //改为true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>本地搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-事件流，事件代理]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-EventFlow%2F</url>
    <content type="text"><![CDATA[事件流事件流模型冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="outer"&gt; &lt;div id="inner"&gt; Click me! &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在冒泡型事件流click事件的传播顺序为：inner-&gt;outer-&gt;body-&gt;html-&gt;document 在捕获型事件流click事件的传播顺序为：document-&gt;html-&gt;body-&gt;outer-&gt;inner DOM事件流DOM事件流采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。 事件捕获阶段：实际目标在捕获阶段不会接收事件。也就是在捕获阶段。上图中为1~3. 处于目标阶段：事件上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。 冒泡阶段：事件又传播回文档。 在DOM事件流中，实际的目标inner在捕获阶段不会接受到事件。这意味着在捕获阶段，事件到outer就停止了，下一个阶段是“处于目标”阶段，于是事件在inner 上发生，并在事件处理中被看成是冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 DOM2级事件定义了两个方法用于处理置顶和删除事件处理程序的操作addEventListener()和removeEventListener()，所有DOM节点都包含这两个方法，并且它们都接受3个参数：要处理的事件名，作为事件处理的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序，反之则是在事件冒泡阶段处理程序。DOM2级方法添加事件处理程序的好处是可以添加多个事件处理程序，会按照添加顺序被处理（无论是捕获还是冒泡）。而IE不同的它有自己的方法attachEvent()和detachEvent,这两个接受相同的两个参数：事件处理程序名称和事件处理程序函数。 DOM2级事件定义了两个方法用于处理置顶和删除事件处理程序的操作addEventListener()和removeEventListener()，所有DOM节点都包含这两个方法，并且它们都接受3个参数：要处理的事件名，作为事件处理的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序，反之则是在事件冒泡阶段处理程序。DOM2级方法添加事件处理程序的好处是可以添加多个事件处理程序，会按照添加顺序被处理（无论是捕获还是冒泡）。 IE的事件流IE没有提供对事件捕获的支持，所以IE跟标准浏览器对DOM事件流实现不一样。而IE不同的它有自己的方法attachEvent()和detachEvent,这两个接受相同的两个参数：事件处理程序名称和事件处理程序函数。 添加和删除事件监听器：w3c： addEventListener/ removeEventListener()IE: attachEvent()/ detachEvent() 事件监听：IE事件监听器使用全局的Event对象，而w3c将event对象作为参数传递给监听器123function handler（event）&#123; event = event || window.event;&#125; 阻止冒泡：IE： e.cancelBubble=true;w3c：e.stopPropagation(); attachEvent 与addEventListener区别一、适应的浏览器版本不同二、attachEvent中的事件带on，而addEventListener中的事件不带on三、参数的个数不同attachEvent()，只有冒泡；addEventListener(事件名称,接收事件处理的函数,bool值) 默认为false，事件句柄在冒泡阶段执行，true在捕获阶段。 event.stopPropagation(); 支持FF=&gt; 停止传播event.cancelBubble = true; 支持IE =&gt; 取消冒泡 自动执行点击事件，兼容IE12345678910111213141516171819202122window.onload = function() &#123; var btn = document.getElementById('my-btn'); var handler = function() &#123; alert(this.tagName); &#125; if (btn.addEventListener) &#123; // 调用的处理程序使用事件目标作为它们的this值 // 此处也可以传递e事件：handler(e); e.target.tagName btn.addEventListener("click", handler, false); &#125; else if (btn.attachEvent) &#123; // 注册的处理程序作为函数调用，它们的this值是全局（window）对象 // 此处也可以传递e事件：handler(e); e.srcElement.tagName btn.attachEvent("onclick", handler.call(btn)); &#125; if (document.all) &#123; btn.click(); &#125; else &#123; var evt = document.createEvent("MouseEvents"); evt.initEvent("click", true, true); btn.dispatchEvent(evt); &#125;;&#125; 事件代理事件代理的原理事件代理的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。 传统事件处理做法是为每个元素添加事件处理器。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; (function()&#123; var colorList=document.getElementById("color-list"); var colors=colorList.getElementsByTagName("li"); for(var i=0;i&lt;colors.length;i++) &#123; colors[i].addEventListener('click',showColor,false); &#125;; function showColor(e) &#123; e=e||window.event; var targetElement=e.target||e.srcElement; alert(targetElement.innerHTML); &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt; 事件代理的处理方式是： 12345678910111213141516171819202122232425&lt;body&gt; &lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; (function()&#123; var colorList=document.getElementById("color-list"); colorList.addEventListener('click',showColor,false); function showColor(e) &#123; e=e||window.event; var targetElement=e.target||e.srcElement; if(targetElement.nodeName.toLowerCase()==="li")&#123; alert(targetElement.innerHTML); &#125; &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt; 事件代理的好处 将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。 DOM更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。 事件代理的问题事件代理同时绑定了li和span，当点击span的时候，li和span都会冒泡。1234567891011&lt;li&gt;&lt;span&gt;li中的span的内容&lt;/span&gt;&lt;/li&gt;&lt;script&gt; $(document).on('click', 'li', function(e)&#123; alert('li li'); &#125;); $(document).on('click', 'span', function(e)&#123; alert('li span'); &#125;)&lt;/script&gt; 解决办法： span的事件处理程序中阻止冒泡 1234$(document).on('click', 'span', function(e)&#123; alert('li span'); e.stopPropagation();&#125;) li的事件处理程序中检测target元素 1234567$(document).on('click', 'li', function (e) &#123; if (e.target.nodeName == 'SPAN') &#123; e.stopPropagation(); return; &#125; alert('li li');&#125;);]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>事件流; 事件代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-数组-字符串方法]]></title>
    <url>%2F2017%2F08%2F06%2Fjavascript-Array-String%2F</url>
    <content type="text"><![CDATA[Array数组 concat()用途 用于连接两个或多个数组，返回被连接的数组。 语法 arrayObject.concat(arrayX,arrayY) 实例12var arr = ['A', 'B', 'C'];var arr2 = [1,2,3]; arr.concat(arr2);//['A','B','C','D',1,2,3],arr并没有被修改 pop()用途 删除并返回最后一个元素 语法 arrayObject.pop() 实例12var arr = ['A', 'B', 'C'];arr.pop();//arr=['A','B'] push()用途 向数组尾部添加一个或更多元素，返回新的长度。 语法 arrayObject.push(elment1,element2…) 实例12var arr = ['A', 'B', 'C'];arr.push('J','K');//['A','B','C','J','K'] shift()用途 删除并返回数组的第一个元素 实例12var arr = ['A', 'B', 'C'];arr.shift();//['B','C'] slice()用途 截取数组的部分长度，然后返回新的数组 实例123arr.slice(0,2);//从开始索引0开始，到结束索引结束，但不包括结束索引，['A','B']arr.slice(2);//从开始到结束，['D'] splice()用途 向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组 语法 arrayObject.splice(index,howmany,item1,item2…) 实例123456var arr = [1,2,3,4,5];arr.splice(2,0,6); // arr=[1,2,6,3,4,5]在下标为2的位置上添加，0表示添加，返回[]arr.splice(2,1,7);// arr=[1,2,7,3,4,5]在下标为2的位置上删除该元素并替换成7，1代表删除，返回[6]arr.splice(1,3); //arr=[1,4,5],返回被删除的元素[2,7,3]arr.splice(1,2,6,8);//arr=[1,6,8]，返回被删除的元素[4,5] unshift()用途 向数组头部添加一个或更多元素，并返回新的长度。 实例12var arr = [1,2,3,4,5];arr.unshift(6,7);//返回新长度3，arr=[6,7,1,2,3,4,5] indexOf()用途 搜索一个指定元素的位置 实例12var arr = [1,2,3,4,5];arr.indexOf(2); // 1 forEach()用途对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。 实例12345678910var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123; console.log(x + '|' + index + '|' + (a === arr));&#125;);// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true map()用途指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 实例12345var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item)&#123; return item*item;&#125;);console.log(arr2); //[1, 4, 9, 16, 25] String charAt()用途 返回在指定位置的字符 实例12var s = 'abcdef';s.charAt(3);// d indexOf()用途 返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。 语法 strObj.indexOf(substr[,startIndex]) 实例12var str = "ABCDECDF";str.indexOf("CD"，1); // 由1位置从左向右查找 123... 返回2 slice()用途 返回字符串片段。 语法strObj.slice(start[,end])start下标从0开始的strObj指定部分其实索引。如果start为负，将它作为length+start处理，此处length为字符串的长度。end下标从0开始的strObj指定部分结束索引。如果end为负，将它作为length+end处理，此处length为字符串的长度。 实例12var str = "ABCDEF";str.slice(2,4); //第2个参数为&lt;end的下标，返回CD split()用途 把一个字符串分割成字符串数组 语法stringObject.split(separator,howmany) 实例12var str="How are you doing today?"console.log(str.split(" ")); // How,are,you,doing,today? substr()用途抽取从 start 下标开始的指定数目的字符 语法stringObject.substr(start,length) 实例12var str = "hello world";console.log(str.substr(3,4));// lo w substring()用途提取字符串中介于两个指定下标之间的字符。 语法stringObject.substring(start,stop) 实例12var str = "hello world";console.log(str.substring(3,5));// lo]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>Array;String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-New关键字]]></title>
    <url>%2F2017%2F08%2F06%2FJavascript-New%2F</url>
    <content type="text"><![CDATA[new操作符具体干了什么呢？12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;;// (1) o.__proto__=Person.prototype; //(2)原型继承 Person.call(o,name);// (3) return o;// (4)&#125;var personB=person("xl");console.log(personB.name); // 输出 xl (1)新建一个空对象o；(2)设置原型链，将o的__proto__指向Person.prototype,完成对Person的原型对象的属性和方法的继承；(3)让Person中的this指向o；(4)返回对象o。此时调用person()函数就相当于new Person()。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-This关键字]]></title>
    <url>%2F2017%2F08%2F06%2FJavascript-This%2F</url>
    <content type="text"><![CDATA[谁调用这样函数或方法，this关键字就指向谁。在JS中，函数调用的方式有 普通函数调用 作为方法来调用 作为构造函数调用 使用apply/call方法来调用 Function.prototype.bind()方法 es6箭头函数 普通函数调用 1234567function person()&#123; this.name="xl"; console.log(this); console.log(this.name);&#125;person(); //输出 window xl 相当于person()作为全局变量window的一个方法来调用，相当于window.person()，所以this志向window. 作为方法来调用 1234567891011var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xlvar showNameA=person.showName;showNameA(); //输出 XL 1.这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出”Xl”.2.这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window. 作为构造函数来调用 12345678910function Person(name)&#123; this.name=name;&#125;var personA=Person("xl");console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xlvar personB=new Person("xl");console.log(personB.name);// 输出 xl//这部分代码的解释见下 1.上面代码没有进行new操作，相当于window对象调用Person(“xl”)方法，那么this指向window对象，并进行赋值操作window.name=”xl”. new操作符12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;; o.__proto__=Person.prototype; //原型继承 Person.call(o,name); return o;&#125;var personB=person("xl");console.log(personB.name); // 输出 xl 1.首先在person里创建空对象o，将o的__proto__指向Person.prototype,完成对Person的原型对象的属性和方法的继承；2.Person.call(o,name)表示将Person对象中的this指向o，即o.name=name;3.返回对象o。 call/apply方法的调用 call/apply方法最大的作用就是改变this的指向。Obj.method.apply(AnotherObj,arguments);123456789var name="XL";var Person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;Person.showName.call(); //输出 "XL"Person.showName();// 输出“Xl” call()不带参数是指向window，若带参数，this指向第一个参数。 Function.prototype.bind()方法 1234567891011var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;,50) &#125;&#125;var person=new Person("xl");person.sayName() //输出 “my name is XL”; setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL1234567891011var name="XL"; function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;.bind(this),50) //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象 &#125; &#125; var person=new Person("xl"); person.sayName(); //输出 “my name is xl”; 这里setTimeout(function(){console.log(this.name)}.bind(this),50);,匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向的Person,而非window,因此最后的输出为”my name is xl”而不是”my name is XL” setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined Eval()函数 该函数执行时，this绑定到当前作用域的对象上。123456789101112var name="XL";var person=&#123; name:"xl", showName:function()&#123; eval("console.log(this.name)"); &#125;&#125;person.showName(); //输出 "xl"var a=person.showName;a(); //输出 "XL" es6箭头函数 箭头函数的 this 始终指向函数定义时的 this，而非执行时。12345678910var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(() =&gt; &#123; this.func() &#125;, 100); // this指向o &#125;&#125;;o.test();// 1 借鉴了[https://segmentfault.com/a/1190000003046071]]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-继承]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Inherit%2F</url>
    <content type="text"><![CDATA[概述 继承方式原型链继承 思想为了让子类继承父类的属性，首先需要定义一个构造函数。然后将父类的新实例赋值给构造函数的原型对象。 代码示例12345678910111213function Parent()&#123; this.name = 'mike'; &#125; function Child()&#123; this.age = 12; &#125; Child.prototype = new Parent();//Child继承Parent，通过原型，形成链条，核心代码 var test = new Child(); alert(test.age); alert(test.name);//得到被继承的属性 alert(test instanceof Child); //确定原型对象和实例的关系。 特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例； 父类新增原型方法/属性，子类能访问到； 简单，易于实现。 缺点 想为子类新增方法和属性，必须在 new Parent()这样的语句之后执行，不能放到构造函数中； 无法实现多继承； 来自原型对象的引用属性是所有实例共享的；（致命） 创建子类实例时，无法向父类构造函数传参。（致命） 构造继承 思想在子类构造函数的内部调用超类的构造函数，通过call()和apply()方法可以在创建的对象上执行构造函数。（没用到原型） 代码示例1234567891011function SuperType() &#123; this.colors = ["red","blue","green"];&#125;function SubType() &#123; SuperType.call(this);//继承了SuperType，核心代码&#125;var instance1 = new SubType();instance1.colors.push("black");console.log(instance1.colors);//"red","blue","green","black"var instance2 = new SubType();console.log(instance2.colors);//"red","blue","green" 特点 解决了原型链继承中，子类实例共享父类引用的属性问题； 创建子类型时，可以向父类传递参数； 可以实现多继承 缺点 实例并不是父类的实例，只是子类的实例； 只能继承父类实例的属性和方法，不能继承原型对象的属性和方法；（没有用到原型链） 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能。（致命，原型链可复用） 组合继承（最常用） 思想使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。通过Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Sub.prototype = new Super();继承父类函数，实现函数复用。 代码示例1234567891011121314151617181920212223242526function SuperType(name) &#123; this.name = name; this.colors = ["red","blue","green"];&#125;SuperType.prototype.sayName = function() &#123;co nsole.log(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this,name);//使用构造函数继承属性，核心代码 this.age = age;&#125;//继承方法SubType.prototype = new SuperType();// 使用原型链继承原型对象的SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;var instance1 = new SubType("EvanChen",18);instance1.colors.push("black");console.log(instance1.colors);//"red","blue","green","black"instance1.sayName();//"EvanChen"instance1.sayAge();//18var instance2 = new SubType("EvanChen666",20);console.log(instance2.colors);//"red","blue","green"instance2.sayName();//"EvanChen666"instance2.sayAge();//20 特点 不存在引用属性共享问题 可传参给父对象 函数可复用 缺点 父类的构造函数被引用了两次 原型式继承 思想 继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式。 代码示例1234567891011121314151617181920212223// 核心模块function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var box = &#123; name : 'trigkit4', arr : ['brother','sister','baba']&#125;;var b1 = obj(box);alert(b1.name);//trigkit4b1.name = 'mike';alert(b1.name);//mikealert(b1.arr);//brother,sister,babab1.arr.push('parents');alert(b1.arr);//brother,sister,baba,parentsvar b2 = obj(box);alert(b2.name);//trigkit4alert(b2.arr);//brother,sister,baba,parents 特点从已有对象衍生新对象不需要创建自定义类型 缺点 原型引用属性会被所有实例共享，因为是用整个父类对象来充当子类的原型对象。 无法实现代码复用 寄生式继承 思想创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。创建新对象-&gt;增强-&gt;返回该对象 寄生组合式继承（最完美） 思想通过寄生方式，去掉父类的实例属性，这样，在调用两次父类的构造函数时，就不会初始化两次实例方法/属性，避免组合继承的缺点。 代码示例123456789101112131415161718192021222324252627282930313233343536373839// 原型式继承代码function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; // 创建对象-&gt;增强对象-&gt;返回对象，核心代码 function create(parent,child)&#123; var f = obj(parent.prototype);//创建对象 f.constructor = child;//增强对象 child.prototype = f; return f; &#125; function Parent(name)&#123; this.name = name; this.arr = ['brother','sister','parents']; &#125; Parent.prototype.run = function () &#123; return this.name; &#125;; function Child(name,age)&#123; Parent.call(this,name);//构造函数 this.age =age; &#125; create(Parent,Child);//通过这里实现继承 var test = new Child('trigkit4',21); test.arr.push('nephew'); console.log(test.arr);//["brother", "sister", "parents", "nephew"] console.log(test.age);// 21 console.log(test.run());//trigkit4 var test2 = new Child('jack',22); console.log(test2.age);// 22 console.log(test2.arr);//["brother", "sister", "parents"] 特点完美]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-原型链]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Prototype%2F</url>
    <content type="text"><![CDATA[普通对象与函数对象 凡是通过new Function()创建的对象都是函数对象，其他的都是普通对象。 构造函数 实例的属性（constructor）指向构造函数。 原型对象 函数对象(构造函数)都有prototype属性，指向函数的原型对象。每个对象都有__proto__属性，但只有函数对象才有prototype。 在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）属性，这个属性指向prototype属性所在的函数（Person） 12Person.prototype.constructor == Person;person1.constructor == Person; 原型对象（Person.prototype）是构造函数（Person）的一个实例。原型对象是用来继承的。 __proto__ 对象都有__proto__的内置属性，指向创建它的构造函数的原型对象。person1.__proto__== Person.protoype1234567891011var b = new Array();b.constructor === Array;b.__proto__ === Array.prototype;var c = new Date();c.constructor === Date;c.__proto__ === Date.prototype;var d = new Function();d.constructor === Function;d.__proto__ === Function.prototype; 所有函数对象的__proto__都指向Function.prototype，它是一个空函数。12345678910111213141516171819202122232425262728Number.__proto__ === Function.prototype // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype // trueError.constructor == Function //trueDate.__proto__ === Function.prototype // trueDate.constructor == Function //true Math和JSON无需new12345Math.__proto__ === Object.prototype // trueMath.construrctor == Object // trueJSON.__proto__ === Object.prototype // trueJSON.construrctor == Object //true 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind。Function.prototype是唯一一个typeof XXX.prototye为function的prototype，其它的构造器的prototype都是object1Object.prototype.__proto__ === null // true 原型链的基本思路 利用原型让引用类型继承另一个引用类型的属性和方法。每隔构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（construrctor），而实例对象都包含一个指向源性对象的内部指针(__proto__)，如果让原型对象等于另一个类型的实例，此时的原型对象将包含另一个原型的指针(__proto__)，另一个原型也包含着一个指向另一个构造函数的指针（construrctor），构成了实例和原型的链条。 总结 所有函数对象的__proto__都指向Function.prototype，是一个空函数。 所有对象的__proto__都指向其构造函数的prototype。 每个对象都有construrctor属性，指向构造函数。 person1.__proto__==Person.protype==person1.construrctor.prototype Object.prototype.__proto__ == null 原型链存在于实例和构造函数的原型对象之间，即 person1.__proto__ == Person.prototype 本文借鉴了[http://www.jianshu.com/p/dee9f8b14771]，http://blog.csdn.net/sinat_21274091/article/details/52741788]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-作用域链]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Scope%2F</url>
    <content type="text"><![CDATA[定义 作用域：是一个“地盘”，一个抽象概念，其中没有变量，要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。作用域中变量的值是执行过程中产生的确定的，而作用域是在函数创建时就确定了。 要查询一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会又冲突。 函数作用域1234567var scope="global"; function t()&#123; console.log(scope); // undefined var scope="local" console.log(scope); // "local"&#125; t(); javascript没有块级作用域，有函数作用域函数作用域:变量在声明它们的函数体以及这个函数嵌套的任意函数体内都是有定义的。javascript没有块级作用域，如下：123456var name="global"; if(true)&#123; var name="local"; console.log(name); // "local" &#125; console.log(name); // "local" 作用域链 作用域链：作用域链的创建是在执行上下文生命周期的创建时建立的。作用域链是当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 简述作用域链 引入一大段话来解释：每一段js代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码中“作用域中”的变量。当js需要查找变量x的值的时候（这个过程称为变量解析（variable resolution）），它会从链的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中没有名为x的属性，js会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。 作用域链举例：在js最顶层代码中（也就是不包括任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域上至少有三个对象。 作用域链创建规则：当定义一个函数时（注意，是定义的时候就开始了），它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来储存它的参数或局部变量，并将这个对象添加保存至那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来说，情况又有所变化：每次调用外部函数的时候，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都要微妙的差别—在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。 可参考[http://blog.csdn.net/yueguanghaidao/article/details/9568071],]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-闭包]]></title>
    <url>%2F2017%2F08%2F04%2FJavascript-Closure%2F</url>
    <content type="text"><![CDATA[定义闭包：有权访问另一个函数作用域中的变量的函数。 在javascript语言中，只有函数内部的子函数才能读取局部变量，所以闭包也可以理解为“定义在一个函数内部的函数”。 闭包是连接函数内部和外部的联系。 javascript的链式作用域结构，子对象会一级一级地向上寻找所有父对象的变量。所以父对象的所有变量对子对象是可见的。 闭包实例将内部函数作为返回值，就可访问函数内的变量。123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 闭包的用处 可以读取函数内部的变量； 让函数内部的变量的值保持在内存中。 123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点 由于闭包会使得函数中的变量被保存在内存中，内存消耗很大，不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是在退出函数之前，将不适用的局部变量全部删除。 闭包会在父函数外部改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，不要随便改变父函数内部变量的值。 可参考[http://www.cnblogs.com/wangfupeng1988/p/3994065.html],[http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html]]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构(javascrit)]]></title>
    <url>%2F2017%2F08%2F02%2FData_Structure%2F</url>
    <content type="text"><![CDATA[线性表1.线性表的定义 零个或多个数据元素的有限序列。 2.线性表的分类 线性表的顺序存储结构：指的是用一段地址连续的存储单元一次存储线性表的数据元素。 线性表的链式存储结构：地址不一定连续来存储线性表的数据元素。 3.线性表的操作3.1 顺序存储3.1.1 查找元素 时间复杂度O(1) 3.1.2 插入操作思路 如果插入位置不合理，抛出异常； 如果线性表长度大于等于数组长度，则抛出异常； 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置； 将要插入元素填入位置i处； 表长加1。时间复杂度O(1). 3.1.3 删除操作思路 如果删除位置不合理，抛出异常； 取出删除元素； 从删除元素的位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置； 表长减1。时间复杂度O(1). 3.2 链式存储3.2.1 查找元素思路 声明一个结点p指向链表第一个结点； 遍历链表，指针p向后移动； 若到链表结尾p为空，则说明第i个元素不存在； 否则查找成果，返回p结点。最好时间复杂度O(1),最坏时间复杂度O(n). 3.2.2 插入元素标准代码:12s.next = p.next;p.next = s; 3.2.3 删除元素标准代码：12q = p.next;p.next = q.next; 4.单链表结构与顺序存储结构的优缺点4.1 时间性能 查找：顺序存储结构O(1),单链表O(n) 插入和删除：顺序存储结构平均时间复杂度O(n),单链表O(1) 4.2 空间性能 顺序存储结构需要预分配存储空间。单链表不需要分配存储空间。 5.单链表的分类5.1 静态链表 用数组描述的链表叫静态链表。 5.2 循环链表 将单链表中终端结点的指针由空指针改为指向头结点，头尾相连的单链表称为单循环链表。 5.3 双向链表 单循环链表增加一个指向前驱结点的指针。 插入操作 1234s.prior = p;s.next = p.next;p.next.prior = s;p.next = s; 删除操作 12p.prior.next = p.next;p.next.prior = p.prior; 栈与队列1. 定义 栈：限定仅在表尾进行插入和删除操作的线性表（后进先出） 队列：只允许在一端进行插入操作，而在另一端进行删除操作的线性表（先进先出） 2.操作2.1 栈进栈push()出栈pop() 3.分类循环队列队列满的条件是(rear+1)%QueueSize == front队列长度公式是(rear-front+QueueSize)%QueueSize 树1.定义树：是n个结点的有限集 2.相关概念度：树的度是树内各结点的度的最大值。深度：树中结点的最大层次称为树的深度。 3.树的存储结构 双亲表示法data,parent 孩子表示法data,parent,firstchild-child,next 孩子兄弟表示法data,firstchild,rightsib 4.二叉树4.1 特点 每个结点最多有两颗子树 左子树和右子树是有顺序的。 4.2 分类 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 二叉树的性质 在二叉树的第i层至多有2i-1个结点。 深度为k的二叉树至多有2k-1个结点。 对任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1。(n=n0+n1+n2,分支数总数等于结点总数减1，分支总数=n-1=n1+2n2) 具有n个结点的完全二叉树的深度为[log2n]+1. 如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i有：1.如果i=1,则结点i是二叉树的根，无双亲；如果i&gt;1,则其双亲是结点[i/2].2.如果2i&gt;n,则结点i无左孩子；否则其左孩子是结点2i。3.如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1。 4.3 二叉树的存储结构二叉链表： lchild,data,rchild 4.4 基本操作4.4.1 插入1234567891011121314151617181920212223242526272829303132333435363738/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125; function BST() &#123; this.root = null; this.insert = insert; this.inOrder = inOrder;&#125;*/ function insert(data) &#123; let node = new TreeNode(data,null,null); //插入根结点 if(this.root == null) &#123; this,root = n; &#125; else &#123; let current = this.root; let parent; while(current) &#123; parent = current; if(data&lt;current.data) &#123; current = current.left; if(current == null) &#123; parent.left = node; break; &#125; &#125; else &#123; current = current.right; if(current == null) &#123; parent.right = node; break; &#125; &#125; &#125; &#125; &#125; 4.4.2 查找最小值（最大值）1234567function getMin() &#123; let current = this.root; while(!(current.left == null)) &#123; current = current.left; &#125; return current.data;&#125; 4.4.3 查找指定值12345678910111213function find(data) &#123; let current = this.root; while(current != null) &#123; if(current.data == data) &#123; return current; &#125; else if (data&lt; current.data) &#123; current = current.left; &#125; else &#123; current = current.right; &#125; &#125; return null;&#125; 4.4.4 删除结点 删除结点有三种情况： 叶子结点，则父结点指向null 仅有左或右子树的结点，则原本指向它的结点就指向它的子结点 左右子树都有结点，则查找删除结点右结点上的最小值，将临时结点上的值复制到待删除结点，然后再删除临时结点。 1234567891011121314151617181920212223242526272829303132333435363738394041function remove(data) &#123; root = removeNode(this.root,data);&#125;//找到最小值function getMin(node) &#123; if (node.left == null) &#123; return node; &#125; else &#123; return getMin(node.left); &#125;&#125;function removeNode(node,data) &#123; if(node == null) &#123; return null; &#125; if(data == node.data) &#123; // 叶子结点 if(node.left == null &amp;&amp; node.right ==null) &#123; return null; &#125; //没有左子结点的结点 if(node.left == null) &#123; return node.right; &#125; if(node.right == null) &#123; return node.left; &#125; // 有2个子结点的结点 let tempNode = getMin(node.right); node.data = tempNode.data; node.right = removeNode(node.right,tempNode.data); return node; &#125; else if (data&lt;node.data) &#123; node.left = removeNode(node.left,data); return node; &#125; else &#123; node.right = removeNode(node.right,data); return node; &#125;&#125; 4.5 二叉树的遍历4.5.1 前序遍历 先访问根结点，然后前序遍历左子树，再前序遍历右子树。1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function PreOrderTraverse(node) &#123; if(!(node == null)) &#123; console.log(node.data); PreOrderTraverse(node.left); PreOrderTraverse(node.right); &#125;&#125; 4.5.2 中序遍历 先中序遍历左子树，访问根结点，再中序遍历右子树。1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function InOrderTraverse(node)&#123; if(!(node == null)) &#123; InOrderTraverse(node.left); console.log(node.show()); InOrderTraverse(node.right); &#125;&#125; 4.5.3 后序遍历 先后序遍历左右子树，再访问根结点。 1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function PostOrderTraverse(node)&#123; if(!(node == null)) &#123; PostOrderTraverse(node.left); console.log(node.show()); PostOrderTraverse(node.right); &#125;&#125; 4.5.4 层序遍历 从根结点开始访问，从上而下逐层遍历。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈，队列，二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(javascript)]]></title>
    <url>%2F2017%2F07%2F21%2FSort-Function%2F</url>
    <content type="text"><![CDATA[二分查找法12345678910111213141516171819function binarysearch(arr, target) &#123; if(arr.length == 0) &#123; return 0; &#125; let low = 0; let high = arr.length; let mid; while(low &lt;= high) &#123; mid = Math.floor((high-low)/2); if(target == arr[mid]) &#123; return mid; &#125; else if (target &lt; arr[mid]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return 0;&#125; 冒泡排序法1234567891011121314151617181920/* 从底层开始冒泡，两两比较，小的放在前面，直到小泡泡*/function BubbleSort(arr) &#123; if (arr.length == 0) &#123; return 0; &#125; let temp = 0; for(let i = 0; i &lt; arr.length - 1; i++) &#123; // i是顶层的泡泡，标记最小的值 for(let j = arr.length - 2; j &gt;= i; j--) &#123; if(arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125; 插入排序法1234567891011121314151617181920212223/*1.默认第一个已经排好序2.依次将接下来的数与数组里的每个元素进行比较，若比前一个小*/function InsertSort(arr) &#123; if (arr.length == 0) &#123; return 0; &#125; let temp = 0; // 存放当前元素 for(let i = 1; i &lt; arr.length; i++) &#123; if(arr[i] &lt; arr[i-1]) &#123; temp = arr[i]; let pre = i - 1; while(pre &gt;= 0 &amp;&amp; temp &lt; arr[pre]) &#123; arr[pre+1] = arr[pre]; pre--; &#125; arr[pre+1] = temp; &#125; &#125; return arr;&#125; 快速排序基本思想: 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。12345678910111213141516171819202122232425262728293031323334/** 它是由冒泡排序改进而来的。在待排序的n个记录中任取一个记录，把该记录放在合适的位置后，* 数据序列被此记录划分为两部分。所有关键字比该记录关键字小的记录放在前一部分，所有比它大的记录放置在后一部分，并把该记录排在这两部分的中间。*/ //交换函数function swap(arr,i,j) &#123; const temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;//分区函数function partition(arr, left , right) &#123; let pivot = left; //基准 let index = pivot + 1; for(let i = index; i&lt;=right;i++) &#123; if(arr[i]&lt;arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr,pivot,index-1); return index-1;&#125;// 快速排序算法function quickSort(arr, left, right) &#123; const len = arr.length; let partitionIndex = 0; if(left&lt;right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1,right); &#125; return arr;&#125; 归并排序思想：两两进行比较，再归并。 归并排序的性能不受输入数据的影响，始终是O(nlogn)，代价是需要额外空间。123456789101112131415161718192021222324252627function mergeSort(arr) &#123; const len = arr.length; if(len&lt;2) &#123; return arr; &#125; let middle = Math.floor(len/2); let left = arr.slice(0,middle); let right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left,right) &#123; let result = [] while(left.length&gt;0 &amp;&amp; right.length&gt;0) &#123; if(left[0] &lt; right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) &#123; result.push(left.shift()); &#125; while(right.length) &#123; result.push(right.shift()); &#125; return result;&#125; 时间复杂度 排序方法 平均情况 最好情况 最坏情况 稳定性 冒泡排序 O(n2) O(n) O(n2) 稳定 直接插入排序 O(n2) O(n) O(n2) 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 快速排序 O(nlogn) O(nlogn) O(n2) 不稳定 可参考http://www.cnblogs.com/dushao/p/6004883.html]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
