<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[javascript-数组-字符串方法]]></title>
      <url>/2017/08/06/javascript-Array-String/</url>
      <content type="html"><![CDATA[<h1 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h1><hr>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a><code>concat()</code></h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>  用于连接两个或多个数组，返回被连接的数组。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>  arrayObject.concat(arrayX,arrayY)</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];　arr.concat(arr2);<span class="comment">//['A','B','C','D',1,2,3],arr并没有被修改</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="pop"><a href="#pop" class="headerlink" title="pop()"></a><code>pop()</code></h2><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p>  删除并返回最后一个元素</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>  arrayObject.pop()</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">arr.pop();<span class="comment">//arr=['A','B']</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="push"><a href="#push" class="headerlink" title="push()"></a><code>push()</code></h2><h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><p>  向数组尾部添加一个或更多元素，返回新的长度。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>  arrayObject.push(elment1,element2…)</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">arr.push(<span class="string">'J'</span>,<span class="string">'K'</span>);<span class="comment">//['A','B','C','J','K']</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="shift"><a href="#shift" class="headerlink" title="shift()"></a><code>shift()</code></h2><h3 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h3><p>  删除并返回数组的第一个元素</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">arr.shift();<span class="comment">//['B','C']</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a><code>slice()</code></h2><h3 id="用途-4"><a href="#用途-4" class="headerlink" title="用途"></a>用途</h3><p>  截取数组的部分长度，然后返回新的数组</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr.slice(<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//从开始索引0开始，到结束索引结束，但不包括结束索引，['A','B']</span></div><div class="line"></div><div class="line">arr.slice(<span class="number">2</span>);<span class="comment">//从开始到结束，['D']</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a><code>splice()</code></h2><h3 id="用途-5"><a href="#用途-5" class="headerlink" title="用途"></a>用途</h3><p>  向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>  arrayObject.splice(index,howmany,item1,item2…)</p>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>); <span class="comment">// arr=[1,2,6,3,4,5]在下标为2的位置上添加，0表示添加，返回[]</span></div><div class="line"></div><div class="line">arr.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>);<span class="comment">// arr=[1,2,7,3,4,5]在下标为2的位置上删除该元素并替换成7，1代表删除，返回[6]</span></div><div class="line">arr.splice(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//arr=[1,4,5],返回被删除的元素[2,7,3]</span></div><div class="line">arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>);<span class="comment">//arr=[1,6,8]，返回被删除的元素[4,5]</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a><code>unshift()</code></h2><h3 id="用途-6"><a href="#用途-6" class="headerlink" title="用途"></a>用途</h3><p>  向数组头部添加一个或更多元素，并返回新的长度。</p>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.unshift(<span class="number">6</span>,<span class="number">7</span>);<span class="comment">//返回新长度3，arr=[6,7,1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a><code>indexOf()</code></h2><h3 id="用途-7"><a href="#用途-7" class="headerlink" title="用途"></a>用途</h3><p>  搜索一个指定元素的位置</p>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.indexOf(<span class="number">2</span>); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><code>forEach()</code></h2><h3 id="用途-8"><a href="#用途-8" class="headerlink" title="用途"></a>用途</h3><p>对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</p>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x, index, a</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x + <span class="string">'|'</span> + index + <span class="string">'|'</span> + (a === arr));</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 输出为：</span></div><div class="line"><span class="comment">// 1|0|true</span></div><div class="line"><span class="comment">// 2|1|true</span></div><div class="line"><span class="comment">// 3|2|true</span></div><div class="line"><span class="comment">// 4|3|true</span></div><div class="line"><span class="comment">// 5|4|true</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h2><h3 id="用途-9"><a href="#用途-9" class="headerlink" title="用途"></a>用途</h3><p>指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arr2 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> item*item;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 4, 9, 16, 25]</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><hr>
<h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a><code>charAt()</code></h2><h3 id="用途-10"><a href="#用途-10" class="headerlink" title="用途"></a>用途</h3><p>  返回在指定位置的字符</p>
<h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'abcdef'</span>;</div><div class="line">s.charAt(<span class="number">3</span>);<span class="comment">// d</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf()"></a><code>indexOf()</code></h2><h3 id="用途-11"><a href="#用途-11" class="headerlink" title="用途"></a>用途</h3><p>  返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>  strObj.indexOf(substr[,startIndex])</p>
<h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"ABCDECDF"</span>;</div><div class="line">str.indexOf(<span class="string">"CD"</span>，<span class="number">1</span>); <span class="comment">// 由1位置从左向右查找 123... 返回2</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a><code>slice()</code></h2><h3 id="用途-12"><a href="#用途-12" class="headerlink" title="用途"></a>用途</h3><p>  返回字符串片段。</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p>strObj.slice(start[,end])<br>start下标从0开始的strObj指定部分其实索引。如果start为负，将它作为length+start处理，此处length为字符串的长度。<br>end下标从0开始的strObj指定部分结束索引。如果end为负，将它作为length+end处理，此处length为字符串的长度。</p>
<h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"ABCDEF"</span>;</div><div class="line">str.slice(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">//第2个参数为&lt;end的下标，返回CD</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="split"><a href="#split" class="headerlink" title="split()"></a><code>split()</code></h2><h3 id="用途-13"><a href="#用途-13" class="headerlink" title="用途"></a>用途</h3><p>  把一个字符串分割成字符串数组</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>stringObject.split(separator,howmany)</p>
<h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str=<span class="string">"How are you doing today?"</span></div><div class="line"><span class="built_in">console</span>.log(str.split(<span class="string">" "</span>)); <span class="comment">// How,are,you,doing,today?</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="substr"><a href="#substr" class="headerlink" title="substr()"></a><code>substr()</code></h2><h3 id="用途-14"><a href="#用途-14" class="headerlink" title="用途"></a>用途</h3><p>抽取从 start 下标开始的指定数目的字符</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><p>stringObject.substr(start,length)</p>
<h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>,<span class="number">4</span>));<span class="comment">// lo w</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="substring"><a href="#substring" class="headerlink" title="substring()"></a><code>substring()</code></h2><h3 id="用途-15"><a href="#用途-15" class="headerlink" title="用途"></a>用途</h3><p>提取字符串中介于两个指定下标之间的字符。</p>
<h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><p>stringObject.substring(start,stop)</p>
<h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">3</span>,<span class="number">5</span>));<span class="comment">// lo</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> javascript语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array;String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript-New关键字]]></title>
      <url>/2017/08/06/Javascript-New/</url>
      <content type="html"><![CDATA[<p>new操作符具体干了什么呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面这段代码模拟了new操作符(实例化对象)的内部过程</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o=&#123;&#125;;<span class="comment">// (1)</span></div><div class="line">  o.__proto__=Person.prototype;  <span class="comment">//(2)原型继承</span></div><div class="line">  Person.call(o,name);<span class="comment">// (3)</span></div><div class="line">  <span class="keyword">return</span> o;<span class="comment">// (4)</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personB=person(<span class="string">"xl"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(personB.name);  <span class="comment">// 输出  xl</span></div></pre></td></tr></table></figure></p>
<p>(1)新建一个空对象o；<br>(2)设置原型链，将o的__proto__指向Person.prototype,完成对Person的原型对象的属性和方法的继承；<br>(3)让Person中的this指向o；<br>(4)返回对象o。<br>此时调用person()函数就相当于new Person()。</p>
]]></content>
      
        <categories>
            
            <category> javascript语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> new </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript-This关键字]]></title>
      <url>/2017/08/06/Javascript-This/</url>
      <content type="html"><![CDATA[<p><strong>谁调用这样函数或方法，this关键字就指向谁。</strong><br>在JS中，函数调用的方式有</p>
<ul>
<li>普通函数调用</li>
<li>作为方法来调用</li>
<li>作为构造函数调用</li>
<li>使用apply/call方法来调用</li>
<li>Function.prototype.bind()方法</li>
<li>es6箭头函数</li>
</ul>
<h1 id="普通函数调用"><a href="#普通函数调用" class="headerlink" title="普通函数调用"></a>普通函数调用</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="keyword">this</span>.name=<span class="string">"xl"</span>;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">person();  <span class="comment">//输出  window  xl</span></div></pre></td></tr></table></figure>
<p>相当于person()作为全局变量window的一个方法来调用，相当于window.person()，所以this志向window.</p>
<h1 id="作为方法来调用"><a href="#作为方法来调用" class="headerlink" title="作为方法来调用"></a>作为方法来调用</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name=<span class="string">"XL"</span>;</div><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"xl"</span>,</div><div class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">person.showName();  <span class="comment">//输出  xl</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> showNameA=person.showName;</div><div class="line">showNameA();    <span class="comment">//输出  XL</span></div></pre></td></tr></table></figure>
<p>1.这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出”Xl”.<br>2.这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window.</p>
<h1 id="作为构造函数来调用"><a href="#作为构造函数来调用" class="headerlink" title="作为构造函数来调用"></a>作为构造函数来调用</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personA=Person(<span class="string">"xl"</span>);</div><div class="line"><span class="built_in">console</span>.log(personA.name); <span class="comment">// 输出  undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);<span class="comment">//输出  xl</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> personB=<span class="keyword">new</span> Person(<span class="string">"xl"</span>);</div><div class="line"><span class="built_in">console</span>.log(personB.name);<span class="comment">// 输出 xl</span></div><div class="line"><span class="comment">//这部分代码的解释见下</span></div></pre></td></tr></table></figure>
<p>1.上面代码没有进行new操作，相当于window对象调用Person(“xl”)方法，那么this指向window对象，并进行赋值操作window.name=”xl”.</p>
<h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面这段代码模拟了new操作符(实例化对象)的内部过程</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o=&#123;&#125;;</div><div class="line">  o.__proto__=Person.prototype;  <span class="comment">//原型继承</span></div><div class="line">  Person.call(o,name);</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personB=person(<span class="string">"xl"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(personB.name);  <span class="comment">// 输出  xl</span></div></pre></td></tr></table></figure>
<p>1.首先在person里创建空对象o，将o的__proto__指向Person.prototype,完成对Person的原型对象的属性和方法的继承；<br>2.Person.call(o,name)表示将Person对象中的this指向o，即o.name=name;<br>3.返回对象o。</p>
<h1 id="call-apply方法的调用"><a href="#call-apply方法的调用" class="headerlink" title="call/apply方法的调用"></a>call/apply方法的调用</h1><hr>
<p><strong>call/apply方法最大的作用就是改变this的指向。</strong><br>Obj.method.apply(AnotherObj,arguments);<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name=<span class="string">"XL"</span>;</div><div class="line"><span class="keyword">var</span> Person=&#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"xl"</span>,</div><div class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Person.showName.call(); <span class="comment">//输出 "XL"</span></div><div class="line">Person.showName();<span class="comment">// 输出“Xl”</span></div></pre></td></tr></table></figure></p>
<p>call()不带参数是指向window，若带参数，this指向第一个参数。</p>
<h1 id="Function-prototype-bind-方法"><a href="#Function-prototype-bind-方法" class="headerlink" title="Function.prototype.bind()方法"></a>Function.prototype.bind()方法</h1><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name=<span class="string">"XL"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"my name is "</span>+<span class="keyword">this</span>.name);</div><div class="line">    &#125;,<span class="number">50</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">"xl"</span>);</div><div class="line">person.sayName()  <span class="comment">//输出  “my name is XL”;</span></div></pre></td></tr></table></figure>
<p>setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name=<span class="string">"XL"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name=name;</div><div class="line">        <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"my name is "</span>+<span class="keyword">this</span>.name);</div><div class="line">            &#125;.bind(<span class="keyword">this</span>),<span class="number">50</span>)  <span class="comment">//注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">"xl"</span>);</div><div class="line">    person.sayName(); <span class="comment">//输出 “my name is xl”;</span></div></pre></td></tr></table></figure></p>
<p>这里setTimeout(function(){console.log(this.name)}.bind(this),50);,匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向的Person,而非window,因此最后的输出为”my name is xl”而不是”my name is XL”</p>
<p><em>setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。<br>函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined</em></p>
<h1 id="Eval-函数"><a href="#Eval-函数" class="headerlink" title="Eval()函数"></a>Eval()函数</h1><hr>
<p>该函数执行时，this绑定到当前作用域的对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name=<span class="string">"XL"</span>;</div><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"xl"</span>,</div><div class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">eval</span>(<span class="string">"console.log(this.name)"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">person.showName();  <span class="comment">//输出  "xl"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a=person.showName;</div><div class="line">a();  <span class="comment">//输出  "XL"</span></div></pre></td></tr></table></figure></p>
<h1 id="es6箭头函数"><a href="#es6箭头函数" class="headerlink" title="es6箭头函数"></a>es6箭头函数</h1><hr>
<p><em>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">x</span> : <span class="number">1</span>,</div><div class="line">    <span class="attr">func</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) &#125;,</div><div class="line">    <span class="attr">test</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.func() &#125;, <span class="number">100</span>);</div><div class="line">        <span class="comment">// this指向o</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">o.test();<span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>借鉴了[<a href="https://segmentfault.com/a/1190000003046071" target="_blank" rel="external">https://segmentfault.com/a/1190000003046071</a>]</p>
]]></content>
      
        <categories>
            
            <category> javascript语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> this </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript-继承]]></title>
      <url>/2017/08/05/javascript-Inherit/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr>
<h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><hr>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>为了让子类继承父类的属性，首先需要定义一个构造函数。然后将父类的新实例赋值给构造函数的原型对象。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">'mike'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">12</span>;</div><div class="line">    &#125;</div><div class="line">    Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//Child继承Parent，通过原型，形成链条，核心代码</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> test = <span class="keyword">new</span> Child();</div><div class="line">    alert(test.age);</div><div class="line">    alert(test.name);<span class="comment">//得到被继承的属性</span></div><div class="line">    alert(test <span class="keyword">instanceof</span> Child); <span class="comment">//确定原型对象和实例的关系。</span></div></pre></td></tr></table></figure>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例；</li>
<li>父类新增原型方法/属性，子类能访问到；</li>
<li>简单，易于实现。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>想为子类新增方法和属性，必须在 new Parent()这样的语句之后执行，不能放到构造函数中；</li>
<li>无法实现多继承；</li>
<li>来自原型对象的引用属性是所有实例共享的；（致命）</li>
<li>创建子类实例时，无法向父类构造函数传参。（致命）</li>
</ol>
<h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><hr>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>在子类构造函数的内部调用超类的构造函数，通过call()和apply()方法可以在创建的对象上执行构造函数。（没用到原型）</p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  SuperType.call(<span class="keyword">this</span>);<span class="comment">//继承了SuperType，核心代码</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red","blue","green","black"</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red","blue","green"</span></div></pre></td></tr></table></figure>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>解决了原型链继承中，子类实例共享父类引用的属性问题；</li>
<li>创建子类型时，可以向父类传递参数；</li>
<li>可以实现多继承</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>实例并不是父类的实例，只是子类的实例；</li>
<li>只能继承父类实例的属性和方法，不能继承原型对象的属性和方法；（没有用到原型链）</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能。（致命，原型链可复用）</li>
</ol>
<h2 id="组合继承（最常用）"><a href="#组合继承（最常用）" class="headerlink" title="组合继承（最常用）"></a>组合继承（最常用）</h2><hr>
<h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。通过Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Sub.prototype = new Super();继承父类函数，实现函数复用。</p>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">co  nsole.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  SuperType.call(<span class="keyword">this</span>,name);<span class="comment">//使用构造函数继承属性，核心代码</span></div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();<span class="comment">// 使用原型链继承原型对象的</span></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"EvanChen"</span>,<span class="number">18</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red","blue","green","black"</span></div><div class="line">instance1.sayName();<span class="comment">//"EvanChen"</span></div><div class="line">instance1.sayAge();<span class="comment">//18</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"EvanChen666"</span>,<span class="number">20</span>);</div><div class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red","blue","green"</span></div><div class="line">instance2.sayName();<span class="comment">//"EvanChen666"</span></div><div class="line">instance2.sayAge();<span class="comment">//20</span></div></pre></td></tr></table></figure>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ol>
<li>不存在引用属性共享问题</li>
<li>可传参给父对象</li>
<li>函数可复用</li>
</ol>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>  父类的构造函数被引用了两次</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><hr>
<h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><p> 继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式。</p>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 核心模块</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">   F.prototype = o;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> box = &#123;</div><div class="line">  <span class="attr">name</span> : <span class="string">'trigkit4'</span>,</div><div class="line">  <span class="attr">arr</span> : [<span class="string">'brother'</span>,<span class="string">'sister'</span>,<span class="string">'baba'</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> b1 = obj(box);</div><div class="line">alert(b1.name);<span class="comment">//trigkit4</span></div><div class="line"></div><div class="line">b1.name = <span class="string">'mike'</span>;</div><div class="line">alert(b1.name);<span class="comment">//mike</span></div><div class="line"></div><div class="line">alert(b1.arr);<span class="comment">//brother,sister,baba</span></div><div class="line">b1.arr.push(<span class="string">'parents'</span>);</div><div class="line">alert(b1.arr);<span class="comment">//brother,sister,baba,parents</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b2 = obj(box);</div><div class="line">alert(b2.name);<span class="comment">//trigkit4</span></div><div class="line">alert(b2.arr);<span class="comment">//brother,sister,baba,parents</span></div></pre></td></tr></table></figure>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>从已有对象衍生新对象不需要创建自定义类型</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>原型引用属性会被所有实例共享，因为是用整个父类对象来充当子类的原型对象。</li>
<li>无法实现代码复用</li>
</ol>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><hr>
<h3 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。<br>创建新对象-&gt;增强-&gt;返回该对象</p>
<h2 id="寄生组合式继承（最完美）"><a href="#寄生组合式继承（最完美）" class="headerlink" title="寄生组合式继承（最完美）"></a>寄生组合式继承（最完美）</h2><hr>
<h3 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a>思想</h3><p>通过寄生方式，去掉父类的实例属性，这样，在调用两次父类的构造函数时，就不会初始化两次实例方法/属性，避免组合继承的缺点。</p>
<h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型式继承代码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">       F.prototype = o;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">   &#125;</div><div class="line"> <span class="comment">// 创建对象-&gt;增强对象-&gt;返回对象，核心代码</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">parent,child</span>)</span>&#123;</div><div class="line">       <span class="keyword">var</span> f = obj(parent.prototype);<span class="comment">//创建对象</span></div><div class="line">       f.constructor = child;<span class="comment">//增强对象</span></div><div class="line">   child.prototype = f;</div><div class="line">   <span class="keyword">return</span> f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = name;</div><div class="line">       <span class="keyword">this</span>.arr = [<span class="string">'brother'</span>,<span class="string">'sister'</span>,<span class="string">'parents'</span>];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   Parent.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">       Parent.call(<span class="keyword">this</span>,name);<span class="comment">//构造函数</span></div><div class="line">       <span class="keyword">this</span>.age =age;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   create(Parent,Child);<span class="comment">//通过这里实现继承</span></div><div class="line"></div><div class="line">   <span class="keyword">var</span> test = <span class="keyword">new</span> Child(<span class="string">'trigkit4'</span>,<span class="number">21</span>);</div><div class="line">   test.arr.push(<span class="string">'nephew'</span>);</div><div class="line">   <span class="built_in">console</span>.log(test.arr);<span class="comment">//["brother", "sister", "parents", "nephew"]</span></div><div class="line"> <span class="built_in">console</span>.log(test.age);<span class="comment">// 21</span></div><div class="line">   <span class="built_in">console</span>.log(test.run());<span class="comment">//trigkit4</span></div><div class="line"></div><div class="line">   <span class="keyword">var</span> test2 = <span class="keyword">new</span> Child(<span class="string">'jack'</span>,<span class="number">22</span>);</div><div class="line"> <span class="built_in">console</span>.log(test2.age);<span class="comment">// 22</span></div><div class="line">   <span class="built_in">console</span>.log(test2.arr);<span class="comment">//["brother", "sister", "parents"]</span></div></pre></td></tr></table></figure>
<h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>完美</p>
]]></content>
      
        <categories>
            
            <category> javascript语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 继承 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript-原型链]]></title>
      <url>/2017/08/05/javascript-Prototype/</url>
      <content type="html"><![CDATA[<h1 id="普通对象与函数对象"><a href="#普通对象与函数对象" class="headerlink" title="普通对象与函数对象"></a>普通对象与函数对象</h1><hr>
<p>  凡是通过new Function()创建的对象都是函数对象，其他的都是普通对象。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><hr>
<p>  实例的属性（constructor）指向构造函数。</p>
<h1 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h1><hr>
<p>  函数对象(构造函数)都有prototype属性，指向函数的原型对象。<br><em>每个对象都有__proto__属性，但只有函数对象才有prototype。</em></p>
<blockquote>
<p>在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）属性，这个属性指向prototype属性所在的函数（Person）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person.prototype.constructor == Person;</div><div class="line">person1.constructor == Person;</div></pre></td></tr></table></figure>
<p><em>原型对象（Person.prototype）是构造函数（Person）的一个实例。</em><br>原型对象是用来继承的。</p>
<h1 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h1><hr>
<p><em>对象都有__proto__的内置属性，指向创建它的构造函数的原型对象。</em><br><strong>person1.__proto__== Person.protoype</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">b.constructor === <span class="built_in">Array</span>;</div><div class="line">b.__proto__ === <span class="built_in">Array</span>.prototype;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">c.constructor === <span class="built_in">Date</span>;</div><div class="line">c.__proto__ === <span class="built_in">Date</span>.prototype;</div><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Function</span>();</div><div class="line">d.constructor === <span class="built_in">Function</span>;</div><div class="line">d.__proto__ === <span class="built_in">Function</span>.prototype;</div></pre></td></tr></table></figure></p>
<p><strong>所有函数对象的__proto__都指向Function.prototype，它是一个空函数。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></div><div class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></div><div class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span> <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></div><div class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></div><div class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></div><div class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></div><div class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></div><div class="line"><span class="built_in">Date</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>Math和JSON无需new<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></div><div class="line"><span class="built_in">Math</span>.construrctor == <span class="built_in">Object</span> <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></div><div class="line"><span class="built_in">JSON</span>.construrctor == <span class="built_in">Object</span> <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind。<br><strong>Function.prototype是唯一一个typeof XXX.prototye为function的prototype，其它的构造器的prototype都是object</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>  <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h1 id="原型链的基本思路"><a href="#原型链的基本思路" class="headerlink" title="原型链的基本思路"></a>原型链的基本思路</h1><hr>
<p>利用原型让引用类型继承另一个引用类型的属性和方法。<br>每隔构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（construrctor），而实例对象都包含一个指向源性对象的内部指针(__proto__)，如果让原型对象等于另一个类型的实例，此时的原型对象将包含另一个原型的指针(__proto__)，另一个原型也包含着一个指向另一个构造函数的指针（construrctor），构成了实例和原型的链条。<br>  <img src="http://img.blog.csdn.net/20161006191631510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Alt text"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<ol>
<li>所有函数对象的__proto__都指向Function.prototype，是一个空函数。</li>
<li>所有对象的__proto__都指向其构造函数的prototype。</li>
<li>每个对象都有construrctor属性，指向构造函数。</li>
<li>person1.__proto__==Person.protype==person1.construrctor.prototype</li>
<li>Object.prototype.__proto__ == null</li>
<li><strong>原型链存在于实例和构造函数的原型对象之间，即 person1.__proto__ == Person.prototype</strong></li>
</ol>
<p>本文借鉴了<br>[<a href="http://www.jianshu.com/p/dee9f8b14771]，" target="_blank" rel="external">http://www.jianshu.com/p/dee9f8b14771]，</a><br><a href="http://blog.csdn.net/sinat_21274091/article/details/52741788" target="_blank" rel="external">http://blog.csdn.net/sinat_21274091/article/details/52741788</a></p>
]]></content>
      
        <categories>
            
            <category> javascript语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原型链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript-作用域链]]></title>
      <url>/2017/08/05/javascript-Scope/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>  <strong>作用域</strong>：是一个“地盘”，一个抽象概念，其中没有变量，要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。作用域中变量的值是执行过程中产生的确定的，而作用域是在函数创建时就确定了。<br>  要查询一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。<br>  <em>作用域最大的用处就是隔离变量，不同作用域下同名变量不会又冲突。</em></p>
<h1 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope=<span class="string">"global"</span>;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// undefined</span></div><div class="line">    <span class="keyword">var</span> scope=<span class="string">"local"</span>  </div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// "local"</span></div><div class="line">&#125;  </div><div class="line">t();</div></pre></td></tr></table></figure>
<p>javascript没有块级作用域，有函数作用域<br><strong>函数作用域</strong>:变量在声明它们的函数体以及这个函数嵌套的任意函数体内都是有定义的。<br>javascript没有块级作用域，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name=<span class="string">"global"</span>;  </div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;  </div><div class="line">    <span class="keyword">var</span> name=<span class="string">"local"</span>;  </div><div class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// "local"  </span></div><div class="line">&#125;  </div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "local"</span></div></pre></td></tr></table></figure></p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>  <strong>作用域链</strong>：作用域链的创建是在执行上下文生命周期的创建时建立的。作用域链是当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
<h1 id="简述作用域链"><a href="#简述作用域链" class="headerlink" title="简述作用域链"></a>简述作用域链</h1><ol>
<li>引入一大段话来解释：<br>每一段js代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。<br>这个作用域链是一个对象列表或者链表，这组对象定义了这段代码中“作用域中”的变量。<br>当js需要查找变量x的值的时候（这个过程称为变量解析（variable resolution）），它会从链的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中没有名为x的属性，js会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。</li>
<li>作用域链举例：<br>在js最顶层代码中（也就是不包括任何函数定义内的代码），作用域链由一个全局对象组成。<br>在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。<br>在一个嵌套的函数体内，作用域上至少有三个对象。</li>
<li>作用域链创建规则：<br>当定义一个函数时（注意，是定义的时候就开始了），它实际上保存一个作用域链。<br>当调用这个函数时，它创建一个新的对象来储存它的参数或局部变量，并将这个对象添加保存至那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。<br>对于嵌套函数来说，情况又有所变化：每次调用外部函数的时候，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都要微妙的差别—在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</li>
</ol>
<p>可参考[<a href="http://blog.csdn.net/yueguanghaidao/article/details/9568071" target="_blank" rel="external">http://blog.csdn.net/yueguanghaidao/article/details/9568071</a>],</p>
]]></content>
      
        <categories>
            
            <category> javascript语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 作用域链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript-闭包]]></title>
      <url>/2017/08/04/Javascript-Closure/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>闭包</strong>：有权访问另一个函数作用域中的变量的函数。<br>  在javascript语言中，只有函数内部的子函数才能读取局部变量，所以闭包也可以理解为“定义在一个函数内部的函数”。<br>    闭包是连接函数内部和外部的联系。<br>    javascript的链式作用域结构，子对象会一级一级地向上寻找所有父对象的变量。所以父对象的所有变量对子对象是可见的。</p>
<h1 id="闭包实例"><a href="#闭包实例" class="headerlink" title="闭包实例"></a>闭包实例</h1><p>将内部函数作为返回值，就可访问函数内的变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　alert(n);</div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> result=f1();</div><div class="line">　　result(); <span class="comment">// 999</span></div></pre></td></tr></table></figure></p>
<h1 id="闭包的用处"><a href="#闭包的用处" class="headerlink" title="闭包的用处"></a>闭包的用处</h1><ol>
<li>可以读取函数内部的变量；</li>
<li>让函数内部的变量的值保持在内存中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　alert(n);</div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> result=f1();</div><div class="line">　　result(); <span class="comment">// 999</span></div><div class="line">　　nAdd();</div><div class="line">　　result(); <span class="comment">// 1000</span></div></pre></td></tr></table></figure>
<p>result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，<em>而f2的存在依赖于f1，因此f1也始终在内存中</em>，不会在调用结束后，被垃圾回收机制（garbage collection）回收。<br>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先<em>在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量</em>。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h1 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h1><ol>
<li>由于闭包会使得函数中的变量被保存在内存中，内存消耗很大，不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是在退出函数之前，将不适用的局部变量全部删除。</li>
<li>闭包会在父函数外部改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，<em>不要随便改变父函数内部变量的值</em>。</li>
</ol>
<p>可参考[<a href="http://www.cnblogs.com/wangfupeng1988/p/3994065.html" target="_blank" rel="external">http://www.cnblogs.com/wangfupeng1988/p/3994065.html</a>],<br>[<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a>]</p>
]]></content>
      
        <categories>
            
            <category> javascript语法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构(javascrit)]]></title>
      <url>/2017/08/02/Data_Structure/</url>
      <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="1-线性表的定义"><a href="#1-线性表的定义" class="headerlink" title="1.线性表的定义"></a>1.线性表的定义</h2><p>  零个或多个数据元素的有限序列。</p>
<h2 id="2-线性表的分类"><a href="#2-线性表的分类" class="headerlink" title="2.线性表的分类"></a>2.线性表的分类</h2><ul>
<li><strong>线性表的顺序存储结构</strong>：指的是用一段地址连续的存储单元一次存储线性表的数据元素。</li>
<li><strong>线性表的链式存储结构</strong>：地址不一定连续来存储线性表的数据元素。</li>
</ul>
<h2 id="3-线性表的操作"><a href="#3-线性表的操作" class="headerlink" title="3.线性表的操作"></a>3.线性表的操作</h2><h3 id="3-1-顺序存储"><a href="#3-1-顺序存储" class="headerlink" title="3.1 顺序存储"></a>3.1 顺序存储</h3><h4 id="3-1-1-查找元素"><a href="#3-1-1-查找元素" class="headerlink" title="3.1.1 查找元素"></a>3.1.1 查找元素</h4><p>  时间复杂度O(1)</p>
<h4 id="3-1-2-插入操作"><a href="#3-1-2-插入操作" class="headerlink" title="3.1.2 插入操作"></a>3.1.2 插入操作</h4><p><strong>思路</strong></p>
<ul>
<li>如果插入位置不合理，抛出异常；</li>
<li>如果线性表长度大于等于数组长度，则抛出异常；</li>
<li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；</li>
<li>将要插入元素填入位置i处；</li>
<li>表长加1。<br>时间复杂度O(1).</li>
</ul>
<h4 id="3-1-3-删除操作"><a href="#3-1-3-删除操作" class="headerlink" title="3.1.3 删除操作"></a>3.1.3 删除操作</h4><p><strong>思路</strong></p>
<ul>
<li>如果删除位置不合理，抛出异常；</li>
<li>取出删除元素；</li>
<li>从删除元素的位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；</li>
<li>表长减1。<br>时间复杂度O(1).</li>
</ul>
<h3 id="3-2-链式存储"><a href="#3-2-链式存储" class="headerlink" title="3.2 链式存储"></a>3.2 链式存储</h3><h4 id="3-2-1-查找元素"><a href="#3-2-1-查找元素" class="headerlink" title="3.2.1 查找元素"></a>3.2.1 查找元素</h4><p><strong>思路</strong></p>
<ul>
<li>声明一个结点p指向链表第一个结点；</li>
<li>遍历链表，指针p向后移动；</li>
<li>若到链表结尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成果，返回p结点。<br>最好时间复杂度O(1),最坏时间复杂度O(n).</li>
</ul>
<h4 id="3-2-2-插入元素"><a href="#3-2-2-插入元素" class="headerlink" title="3.2.2 插入元素"></a>3.2.2 插入元素</h4><p>标准代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s.next = p.next;</div><div class="line">p.next = s;</div></pre></td></tr></table></figure></p>
<h4 id="3-2-3-删除元素"><a href="#3-2-3-删除元素" class="headerlink" title="3.2.3 删除元素"></a>3.2.3 删除元素</h4><p>标准代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">q = p.next;</div><div class="line">p.next = q.next;</div></pre></td></tr></table></figure></p>
<h2 id="4-单链表结构与顺序存储结构的优缺点"><a href="#4-单链表结构与顺序存储结构的优缺点" class="headerlink" title="4.单链表结构与顺序存储结构的优缺点"></a>4.单链表结构与顺序存储结构的优缺点</h2><h3 id="4-1-时间性能"><a href="#4-1-时间性能" class="headerlink" title="4.1 时间性能"></a>4.1 时间性能</h3><ul>
<li>查找：顺序存储结构O(1),单链表O(n)</li>
<li>插入和删除：顺序存储结构平均时间复杂度O(n),单链表O(1)</li>
</ul>
<h3 id="4-2-空间性能"><a href="#4-2-空间性能" class="headerlink" title="4.2 空间性能"></a>4.2 空间性能</h3><p>  顺序存储结构需要预分配存储空间。单链表不需要分配存储空间。</p>
<h2 id="5-单链表的分类"><a href="#5-单链表的分类" class="headerlink" title="5.单链表的分类"></a>5.单链表的分类</h2><h3 id="5-1-静态链表"><a href="#5-1-静态链表" class="headerlink" title="5.1 静态链表"></a>5.1 静态链表</h3><p>  用数组描述的链表叫<strong>静态链表</strong>。</p>
<h3 id="5-2-循环链表"><a href="#5-2-循环链表" class="headerlink" title="5.2 循环链表"></a>5.2 循环链表</h3><p>  将单链表中终端结点的指针由空指针改为指向头结点，头尾相连的单链表称为<strong>单循环链表</strong>。</p>
<h3 id="5-3-双向链表"><a href="#5-3-双向链表" class="headerlink" title="5.3 双向链表"></a>5.3 双向链表</h3><p>  单循环链表增加一个指向前驱结点的指针。</p>
<ul>
<li><p>插入操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s.prior = p;</div><div class="line">s.next = p.next;</div><div class="line">p.next.prior = s;</div><div class="line">p.next = s;</div></pre></td></tr></table></figure>
</li>
<li><p>删除操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p.prior.next = p.next;</div><div class="line">p.next.prior = p.prior;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li><strong>栈</strong>：限定仅在表尾进行插入和删除操作的线性表（后进先出）</li>
<li><strong>队列</strong>：只允许在一端进行插入操作，而在另一端进行删除操作的线性表（先进先出）</li>
</ul>
<h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><h3 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h3><p>进栈push()<br>出栈pop()</p>
<h2 id="3-分类"><a href="#3-分类" class="headerlink" title="3.分类"></a>3.分类</h2><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>队列满的条件是(rear+1)%QueueSize == front<br>队列长度公式是(rear-front+QueueSize)%QueueSize</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>树</strong>：是n个结点的有限集</p>
<h2 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2.相关概念"></a>2.相关概念</h2><p><strong>度</strong>：树的度是树内各结点的度的最大值。<br><strong>深度</strong>：树中结点的最大层次称为树的深度。</p>
<h2 id="3-树的存储结构"><a href="#3-树的存储结构" class="headerlink" title="3.树的存储结构"></a>3.树的存储结构</h2><ol>
<li>双亲表示法<br>data,parent</li>
<li>孩子表示法<br>data,parent,firstchild-child,next</li>
<li>孩子兄弟表示法<br>data,firstchild,rightsib</li>
</ol>
<h2 id="4-二叉树"><a href="#4-二叉树" class="headerlink" title="4.二叉树"></a>4.二叉树</h2><h3 id="4-1-特点"><a href="#4-1-特点" class="headerlink" title="4.1 特点"></a>4.1 特点</h3><ul>
<li>每个结点最多有两颗子树</li>
<li>左子树和右子树是有顺序的。</li>
</ul>
<h3 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h3><ol>
<li>满二叉树<br>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</li>
<li>完全二叉树<br>对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</li>
</ol>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol>
<li>在二叉树的第i层至多有2<sup>i-1</sup>个结点。</li>
<li>深度为k的二叉树至多有2<sup>k</sup>-1个结点。</li>
<li>对任何一棵二叉树T，如果其终端结点数为n<sub>0</sub>,度为2的结点数为n<sub>2</sub>,则n<sub>0</sub>=n<sub>2</sub>+1。(n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>,分支数总数等于结点总数减1，分支总数=n-1=n<sub>1</sub>+2n<sub>2</sub>)</li>
<li>具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1.</li>
<li>如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i有：<br>1.如果i=1,则结点i是二叉树的根，无双亲；如果i&gt;1,则其双亲是结点[i/2].<br>2.如果2i&gt;n,则结点i无左孩子；否则其左孩子是结点2i。<br>3.如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1。</li>
</ol>
<h3 id="4-3-二叉树的存储结构"><a href="#4-3-二叉树的存储结构" class="headerlink" title="4.3 二叉树的存储结构"></a>4.3 二叉树的存储结构</h3><p>二叉链表： lchild,data,rchild</p>
<h3 id="4-4-基本操作"><a href="#4-4-基本操作" class="headerlink" title="4.4 基本操作"></a>4.4 基本操作</h3><h4 id="4-4-1-插入"><a href="#4-4-1-插入" class="headerlink" title="4.4.1 插入"></a>4.4.1 插入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  function TreeNode(x) &#123;</div><div class="line">    this.val = x;</div><div class="line">    this.left = null;</div><div class="line">    this.right = null;</div><div class="line">  &#125;</div><div class="line">  function BST() &#123;</div><div class="line">    this.root = null;</div><div class="line">    this.insert = insert;</div><div class="line">    this.inOrder = inOrder;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(data,<span class="literal">null</span>,<span class="literal">null</span>);</div><div class="line">    <span class="comment">//插入根结点</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>,root = n;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</div><div class="line">      <span class="keyword">let</span> parent;</div><div class="line">      <span class="keyword">while</span>(current) &#123;</div><div class="line">        parent = current;</div><div class="line">        <span class="keyword">if</span>(data&lt;current.data) &#123;</div><div class="line">          current = current.left;</div><div class="line">          <span class="keyword">if</span>(current == <span class="literal">null</span>) &#123;</div><div class="line">            parent.left = node;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          current = current.right;</div><div class="line">          <span class="keyword">if</span>(current == <span class="literal">null</span>) &#123;</div><div class="line">            parent.right = node;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="4-4-2-查找最小值（最大值）"><a href="#4-4-2-查找最小值（最大值）" class="headerlink" title="4.4.2 查找最小值（最大值）"></a>4.4.2 查找最小值（最大值）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMin</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</div><div class="line">  <span class="keyword">while</span>(!(current.left == <span class="literal">null</span>)) &#123;</div><div class="line">    current = current.left;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> current.data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-4-3-查找指定值"><a href="#4-4-3-查找指定值" class="headerlink" title="4.4.3 查找指定值"></a>4.4.3 查找指定值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</div><div class="line">  <span class="keyword">while</span>(current != <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(current.data == data) &#123;</div><div class="line">      <span class="keyword">return</span> current;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data&lt; current.data) &#123;</div><div class="line">      current = current.left;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      current = current.right;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-4-4-删除结点"><a href="#4-4-4-删除结点" class="headerlink" title="4.4.4 删除结点"></a>4.4.4 删除结点</h4><p>  删除结点有三种情况：</p>
<ul>
<li>叶子结点，则父结点指向null</li>
<li>仅有左或右子树的结点，则原本指向它的结点就指向它的子结点</li>
<li>左右子树都有结点，则查找删除结点右结点上的最小值，将临时结点上的值复制到待删除结点，然后再删除临时结点。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  root = removeNode(<span class="keyword">this</span>.root,data);</div><div class="line">&#125;</div><div class="line"><span class="comment">//找到最小值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMin</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> node;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> getMin(node.left);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">node,data</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(data == node.data) &#123;</div><div class="line">    <span class="comment">// 叶子结点</span></div><div class="line">    <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right ==<span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//没有左子结点的结点</span></div><div class="line">    <span class="keyword">if</span>(node.left == <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> node.right;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(node.right == <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> node.left;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 有2个子结点的结点</span></div><div class="line">    <span class="keyword">let</span> tempNode = getMin(node.right);</div><div class="line">    node.data = tempNode.data;</div><div class="line">    node.right = removeNode(node.right,tempNode.data);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data&lt;node.data) &#123;</div><div class="line">    node.left = removeNode(node.left,data);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    node.right = removeNode(node.right,data);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-5-二叉树的遍历"><a href="#4-5-二叉树的遍历" class="headerlink" title="4.5 二叉树的遍历"></a>4.5 二叉树的遍历</h3><h4 id="4-5-1-前序遍历"><a href="#4-5-1-前序遍历" class="headerlink" title="4.5.1 前序遍历"></a>4.5.1 前序遍历</h4><p>  先访问根结点，然后前序遍历左子树，再前序遍历右子树。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  function TreeNode(x) &#123;</div><div class="line">    this.val = x;</div><div class="line">    this.left = null;</div><div class="line">    this.right = null;</div><div class="line">  &#125;</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PreOrderTraverse</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(!(node == <span class="literal">null</span>)) &#123;</div><div class="line">    <span class="built_in">console</span>.log(node.data);</div><div class="line">    PreOrderTraverse(node.left);</div><div class="line">    PreOrderTraverse(node.right);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-5-2-中序遍历"><a href="#4-5-2-中序遍历" class="headerlink" title="4.5.2 中序遍历"></a>4.5.2 中序遍历</h4><p>  先中序遍历左子树，访问根结点，再中序遍历右子树。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  function TreeNode(x) &#123;</div><div class="line">    this.val = x;</div><div class="line">    this.left = null;</div><div class="line">    this.right = null;</div><div class="line">  &#125;</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">InOrderTraverse</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(!(node == <span class="literal">null</span>)) &#123;</div><div class="line">          InOrderTraverse(node.left);</div><div class="line">          <span class="built_in">console</span>.log(node.show());</div><div class="line">          InOrderTraverse(node.right);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-5-3-后序遍历"><a href="#4-5-3-后序遍历" class="headerlink" title="4.5.3 后序遍历"></a>4.5.3 后序遍历</h4><p>  先后序遍历左右子树，再访问根结点。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  function TreeNode(x) &#123;</div><div class="line">    this.val = x;</div><div class="line">    this.left = null;</div><div class="line">    this.right = null;</div><div class="line">  &#125;</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PostOrderTraverse</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(!(node == <span class="literal">null</span>)) &#123;</div><div class="line">          PostOrderTraverse(node.left);</div><div class="line">          <span class="built_in">console</span>.log(node.show());</div><div class="line">          PostOrderTraverse(node.right);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-5-4-层序遍历"><a href="#4-5-4-层序遍历" class="headerlink" title="4.5.4 层序遍历"></a>4.5.4 层序遍历</h4><p>  从根结点开始访问，从上而下逐层遍历。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 栈，队列，二叉树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排序算法(javascript)]]></title>
      <url>/2017/07/21/Sort-Function/</url>
      <content type="html"><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarysearch</span>(<span class="params">arr, target</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span>(arr.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">let</span> low = <span class="number">0</span>;</div><div class="line">	<span class="keyword">let</span> high = arr.length;</div><div class="line">	<span class="keyword">let</span> mid;</div><div class="line">	<span class="keyword">while</span>(low &lt;= high) &#123;</div><div class="line">		mid = <span class="built_in">Math</span>.floor((high-low)/<span class="number">2</span>);</div><div class="line">		<span class="keyword">if</span>(target == arr[mid]) &#123;</div><div class="line">			<span class="keyword">return</span> mid;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</div><div class="line">			high = mid - <span class="number">1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			low = mid + <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">	从底层开始冒泡，两两比较，小的放在前面，直到小泡泡</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">let</span> temp = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">// i是顶层的泡泡，标记最小的值</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j = arr.length - <span class="number">2</span>; j &gt;= i; j--) &#123;</div><div class="line">			<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">				temp = arr[j];</div><div class="line">				arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">				arr[j+<span class="number">1</span>] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="插入排序法"><a href="#插入排序法" class="headerlink" title="插入排序法"></a>插入排序法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">1.默认第一个已经排好序</div><div class="line">2.依次将接下来的数与数组里的每个元素进行比较，若比前一个小</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">InsertSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line"> 	<span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</div><div class="line"> 	  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> 	&#125;</div><div class="line">   <span class="keyword">let</span> temp = <span class="number">0</span>;   <span class="comment">// 存放当前元素</span></div><div class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">     <span class="keyword">if</span>(arr[i] &lt; arr[i<span class="number">-1</span>]) &#123;</div><div class="line">       temp = arr[i];</div><div class="line">       <span class="keyword">let</span> pre = i - <span class="number">1</span>;</div><div class="line"></div><div class="line">       <span class="keyword">while</span>(pre &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[pre]) &#123;</div><div class="line">         arr[pre+<span class="number">1</span>] = arr[pre];</div><div class="line">         pre--;</div><div class="line">       &#125;</div><div class="line">       arr[pre+<span class="number">1</span>] = temp;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>基本思想</strong>: 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* 它是由冒泡排序改进而来的。在待排序的n个记录中任取一个记录，把该记录放在合适的位置后，</div><div class="line">* 数据序列被此记录划分为两部分。所有关键字比该记录关键字小的记录放在前一部分，所有比它大的记录放置在后一部分，并把该记录排在这两部分的中间。</div><div class="line">*/</div><div class="line">	<span class="comment">//交换函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> temp = arr[i];</div><div class="line">	arr[i] = arr[j];</div><div class="line">	arr[j] = temp;</div><div class="line">&#125;</div><div class="line"><span class="comment">//分区函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left , right</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> pivot = left; <span class="comment">//基准</span></div><div class="line">	<span class="keyword">let</span> index = pivot + <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = index; i&lt;=right;i++) &#123;</div><div class="line">		<span class="keyword">if</span>(arr[i]&lt;arr[pivot]) &#123;</div><div class="line">			swap(arr, i, index);</div><div class="line">			index++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	swap(arr,pivot,index<span class="number">-1</span>);</div><div class="line">	<span class="keyword">return</span> index<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 快速排序算法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> len = arr.length;</div><div class="line">	<span class="keyword">let</span> partitionIndex = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(left&lt;right) &#123;</div><div class="line">		partitionIndex = partition(arr, left, right);</div><div class="line">		quickSort(arr, left, partitionIndex<span class="number">-1</span>);</div><div class="line">		quickSort(arr, partitionIndex+<span class="number">1</span>,right);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>思想</strong>：两两进行比较，再归并。<br>    归并排序的性能不受输入数据的影响，始终是O(nlogn)，代价是需要额外空间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> len = arr.length;</div><div class="line">	<span class="keyword">if</span>(len&lt;<span class="number">2</span>) &#123;</div><div class="line">		<span class="keyword">return</span> arr;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</div><div class="line">	<span class="keyword">let</span> left = arr.slice(<span class="number">0</span>,middle);</div><div class="line">	<span class="keyword">let</span> right = arr.slice(middle);</div><div class="line">	<span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> result = []</div><div class="line">	<span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</div><div class="line">			result.push(left.shift());</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			result.push(right.shift());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span> (left.length) &#123;</div><div class="line">		result.push(left.shift());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(right.length) &#123;</div><div class="line">		result.push(right.shift());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><table>
<thead>
<tr>
<th>排序方法</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n<sup>2</sup>)</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<p>可参考<a href="http://www.cnblogs.com/dushao/p/6004883.html" target="_blank" rel="external">http://www.cnblogs.com/dushao/p/6004883.html</a></p>
]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
