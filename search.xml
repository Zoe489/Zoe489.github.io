<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2017%2F09%2F12%2Fgit%2F</url>
    <content type="text"><![CDATA[新建12345# 新建git代码库$ git init# 下载一个项目和它的整个代码历史$ git clone [url] 配置git的配置文件为.gitconfig 123456# 显示当前的git配置$ git config --list# 设置提交代码时的用户信息$ git config user.name "[name]"$ git config user.email "[email address]" 添加123456789# 将工作文件修改提交到本地暂存区$ git add &lt;file&gt;# 将所有修改过的工作文件提交到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p 删除12# 删除工作区文件，并将这次删除放入暂存区$ git rm [file1] [file2] 提交12345678# 提交暂存区到仓库区$ git commit -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v 分支12345678910111213141516171819202122232425262728293031323334# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch][remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit,合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 查看信息12345678# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示暂存区和工作区的差异$ git diff 远程同步1234567891011121314151617# 下载远程仓库的所有变动$ git fetch# 显示所有远程仓库$ git remote -v# 增加一个新的远程仓库$ git remote add [shortname][url]# 取回远程仓库的变化，并与本地分支合并$git pull [remote][branch]# 上传本地指定分支到远程仓库$ git push [remote][branch]# 推送所有分支到远程仓库$ git push [remote] --all 恢复12345678# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复暂存区的所有文件到工作区$ git checkout# 重置暂存区的指定文件，与上次commit保持一直，但工作区不变$ git reset [file]]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js前端面试笔记]]></title>
    <url>%2F2017%2F09%2F12%2FinterviewQuestions%2F</url>
    <content type="text"><![CDATA[8.31 阿里一轮电话面试1. js的基本数据类型 检测给定变量的数据类型可用typeof （1） Undefined： 只有一个值，就是undefined，在使用var声明变量但未对其加以初始化，这个变量就是undefined。 （2） Null： 只有一个值，就是null。从逻辑角度来看，null值表示一个空对象指针，使用typeof操作符检测null值会返回object。 （3） Boolean：true和false （4） Number：NAN与任何值都不想等，包括NAN本身。Number(), parseInt(), parseFloat()。 （5） String：字符串 （6） Object：js中的对象是一组数据和功能的集合。 2. undefined和null的区别 （1）null是一个字面量（而不是全局对象的一个属性,undefined 是）; （2）null是一个表示”无”的对象, Number(null) == 0；undefined是一个表示”无”的原始值, Number(undefined) == NaN。 （3）当声明的变量还未被初始化时,变量的默认值为undefined。 （4）null用来表示尚未存在的对象,常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2）调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）函数没有返回值时，默认返回undefined。 （4）对象没有赋值的属性，该属性的值为undefined。 null表示“没有对象”，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 3. js的继承 ，extends （1）原型链继承 定义构造函数，将父类的新实例赋值给子类构造函数的原型对象。 （2）构造函数继承 在子类构造函数的内部调用超类的构造函数，通过call()和apply()方法可以在创建的对象上执行构造函数。（没用到原型）。 （3）组合继承 使用原型链实现对父类属性的继承，使用构造函数来实现对实例属性的继承。 （4）原型式继承 （5）寄生式继承 （6）寄生组合式继承 ES6中的class的继承 通过extends关键字，继承了父类所有属性和方法。 Super关键字代表父类的构造函数，用来新建父类的this对象。子类必须在constructor方法中调用super方法，否则新建实例会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。 class中含有constructor()构造函数，this代表实例对象。Class类还定义了toString()方法。 4. 跨域，ajax的参数，jsonp，同源策略 URL由协议、域名、端口和路径组成。 为什么要有同源策略： 比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手。 解决跨域的方法： （1） CORS跨域资源共享 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 （2） JSONP 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 JSONP通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求，格式要求严格。 （3） 通过修改document.domain来跨子域 （4） 使用window.name来进行跨域 （5） 使用HTML5的window.postMessage方法跨域 5. ES6的特性，let,const,var的区别，箭头函数的作用（1）let声明的变量只在let命令所在的代码块内有效（2）let不存在变量提升，即在变量声明之前不能使用。而var定义的变量在声明前是可以使用的，值为undefined。暂时性死区。（3）在相同作用域内不允许重复声明。块级作用域的好处： （1）如果没有块级作用域，内层变量可能会覆盖外层变量。 （2）用来计数的循环变量泄露为全局变量。 箭头函数是的表达更加简洁。 （1） 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2） 不可以当作构造函数，也就是说，不可以使用new命令。 （3） 不可以使用arguments对象，该对象在函数体内不存在。如何要用可以用rest参数代替。 （4） 不可以使用yield命令，因此箭头函数不能做generator函数. Set类似于数组，但成员的值都是唯一的，没有重复值。 操作方法： -set.add(value)添加某个值，返回set结构本身 -set.delete(value)删除某个值，返回一个布尔值，表示删除是否成功。 -has(value)返回一个布尔值，表示是否包含该值。 -clear()删除所有元素，没有返回值。 遍历方法： -keys()返回键名的遍历器 -values()返回键值的遍历器 -entries()返回键值对的遍历器 -forEach()使用回调函数遍历每个成员 Map是键值对的集合 Iterator遍历器 用next方法来移动指针。 -for..of遍历数组，set和map。 Module的语法 Commonjs用于服务器端，AMD规范用于浏览器。ES6的加载为编译时加载或静态加载，即ES6可以在编译时就完成模块加载，效率比CommonJS模块的加载方式高 Import, export命令 通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令 6. promise的方法 Promise是异步编程的一种解决方案。 Promise对象有以下两个特点： 1） 对象的状态不受外界影响。有三种状态，pending, fulfilled, rejected。 2） 一旦状态改变，就不会再变，任何时候都可以得到这个结果。成为resolved。 Promise对象是一个构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 Promise的方法 （1） Promise.prototype.then() then方法返回的是新的promise对象。 （2） Promise.prototpe.catch() 是发生错误时的回调函数 （3） Promise.all()，promise.race() 用于将多个promise实例，包装成一个新的promise实例。 （4） promise.resolve()，promise.reject() 将现有的对象转化为promise对象 7. 状态码200，301，302，304，500，504-200 ： OK，表示一切正常-301 ： 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替-302 ： Found，临时移动，与301类似，但资源知识临时被移动。客户端应继续使用原有URL。-304 ： Not Modified，未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回指定日期之后修改的资源。-500 ： Internal Sever error，服务器内部错误，无法完成请求。-502 ： Bad Gateway，充当网关或代理的服务器，从远端服务器接收到了一个无效的请求。-504 ： Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求。 8. 如何学习前端知识,前端有什么作用9. webpack有什么用Webpack分析项目结构，找到javascript模块以及其它一些浏览器不能直接运行的拓展语言，并将其打包为合适的格式以供浏览器使用。web开发中常用到的静态资源主要有JavaScript、CSS、图片、Jade等文件，webpack中将静态资源文件称之为模块。webpack是一个module bundler(模块打包工具)，其可以兼容多种js书写规范，且可以处理模块间的依赖关系，具有更强大的js模块化的功能。Webpack对它们进行统一的管理以及打包发布 为什么使用webpack： a) 模块化，把复杂的程序细小为小的文件 b) 在javascript上拓展的开发语言，浏览器不能直接识别的。 c) Scss, less等css预处理器 10. HTML5新特性： 用于绘图的canvas元素 用于媒介回放的video和audio元素 对本地离线存储的更好的支持 新的特殊内容元素，比如article,footer,header,nav,section 新的表单控件，比如calendar,date,time,email,url,search web上的视频HTML5规定了一种通过video元素来包含视频的标准方法。 web上的音频HTML5规定了一种通过audio元素来包含音频的标准方法。 拖放Drag和drop在HTML5中，拖放是标准的一部分，任何元素都能够拖放。 CanvasHTML5中canvas元素使用javascript在网页上绘制图像。画布是一个举行区域，可以控制其每一像素。canvas拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 SVGSVG指可伸缩矢量图形，定义用于网络的基于矢量的图形，使用XML格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失。 Geolocation地理定位HTML5 Geolocation API用于获得用户的地理位置。-navigator.geolocation.getCurrentPosition(); 在客户端存储数据HTML5提供了两种在客户端存储数据的新方法： localStorage - 没有时间限制的数据存储 sessionStorage -针对一个session的数据存储之前都是由cookie完成的，但是cookie不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得cookie速度很慢而且效率也不高。 11. 为什么使用vue(1) vue的核心库只关注视图层，并且非常容易学习(2) 单页应用程序(SPA)，一个页面就是应用。(3) jquery是操作DOM来才做HTML的DOM结构， 12. vue的父子之间通信在vue中，父子组件的关系可以总结为props down，events up。父组件通过props向下传递数据给子组件，子组件通过events给父组件发送信息。 -events每个Vue实例都实现了事件接口。-使用$on(eventName)监听事件-使用$emit(eventName)触发事件，子组件向父组件触发事件$on和$emit可以实现非父子组件通信 12. 你所了解的前端的东西有哪些基础：javascript, css, html，对应的版本ES6, CSS3, HTML5前端框架：react, vue, angular，zepto前端库： jquery, bootstrap, elementUI, amazeUI, echarts, canave模板引擎： jade前端模块管理： ES6, CommonJS, AMD前端构建工具：webpack, grunt, gulp版本控制： git, github, svn交互： ajax, http, https,后端： php, java(jsp), nodejs，服务端框架：express, koa, servlet数据库： mysql, oracle, mongodb, redis 13. 什么是闭包，闭包的优点与缺点闭包是有权访问另一个函数作用域中的变量的函数。在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包是定义在一个函数内部的函数。 闭包的用处：1） 可以读取函数内部的变量2）让函数内部的变量的值保持在内存中。 闭包的注意点：1） 闭包会使得函数中的变量保存在内存中，不能滥用闭包。解决方法，在退出函数之前，将不适用的局部变量全部删除。2） 闭包会在父函数外部改变父函数内部变量的值。解决方法，不要随便改变父函数内部变量的值。 闭包的缺点：闭包会常驻内存，会增大内存的使用量，使用不当容易造成内存泄露。 14. js内置对象的arguments-typeof arguments ===’object’通过arguments对象能让函数调用数目不定的参数，代表当前方法被传入的所有的参数。 15. js的异步（1）Generator函数执行generator函数会返回一个遍历器对象，也就是generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历generator函数内部的每一个状态。特征：1） function关键字与韩树明之间有一个星号；2）函数体内使用yield表达式，定义不同的内部状态。调用generator函数后，该函数并不执行，返回的也不是函数运行的结果，而是一个指向内部状态的指针。下一步必须调用遍历器的next方法，使得指针向下一个状态。每次调用next方法，内部指针就从函数头或上一次停下来的地方开始执行，直到遇到下一个yield表达式或return。（2）async函数在function前面加async把generator中的yield改成 await。返回值是promise对象。（3）ajax是异步javascript和XML，用于在WEB页面中实现异步数据交互创建XMLHttpResponse对象-&gt;创建新的http请求，指定http方法，url等-&gt;状态变化函数-&gt;发送请求（4）promise 搜狐新媒体一面：1. 双等号与三等号===运算符判断相等的流程是怎样的 如果两个值不是相同类型，它们不相等 如果两个值都是null或者都是undefined，它们相等 如果两个值都是布尔类型true或者都是false，它们相等 如果其中有一个是NaN，它们不相等 如果都是数值型并且数值相等，他们相等， -0等于0 如果他们都是字符串并且在相同位置包含相同的16位值，它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等 如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等 ==运算符判断相等的流程是怎样的 如果两个值类型相同，按照===比较方法进行比较 如果类型不同，使用如下规则进行比较 如果其中一个值是null，另一个是undefined，它们相等 如果一个值是数字另一个是字符串，将字符串转换为数字进行比较 如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较 其他所有情况都认为不相等 2. Undefined和null3. Typeof undefined, typeof null4. 冒泡与捕获5. 图片轮播原生js6. 是否研究vue的原生js7. 前端包括的内容CVTE一面1. CSS盒子模型 margin：清除边框外的区域，外边距是透明的。 border：围绕在内边距和内容外的边框。 padding：清除内容周围的区域，内边距是透明的。 content：盒子的内容，显示文本和图像。 总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 2. 清除浮动的方法-relative定位： 相对定位元素的定位是相对其正常的位置。相对定位元素经常被用来作为绝对定位元素的容器块。-absolute定位： 绝对定位的元素的位置相对于最近的已定位的父元素，如果元素没有已定位的父元素，那么它的位置相对与。absolute定位使元素的位置与文档流无关，因此不占据空间。absolute定位的元素和其他元素重叠。z - index用来确定重叠元素的深度。-float浮动：会使元素向左或向右移动，其周围的元素也会重新排列。往往用于图像。浮动规则： 元素是水平移动的。 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动元素之后的元素将围绕它。 浮动元素之前的元素将不会受到影响。 如果是彼此相邻的浮动元素，如果有空间，它们会彼此相邻。 浮动产生的副作用：（1）块级元素会钻到浮动元素下面，被浮动元素所覆盖。（2）与浮动元素同级的非浮动元素会跟随其后。（3）浮动元素的父元素塌陷 清除浮动：（1） 额外div：在需要清除浮动的元素前面添加一个空的div，给这个div设置，clear: both.（2） 高度塌陷时，由于父元素没有设置高度和宽度，当子元素设置了浮动，脱离了标准流，可以在父元素中设置overflow:hidden // 或auto，或者给浮动元素父级设置高度（3）利用伪类元素来清除有浮动的标签。代表一个元素之后最近的元素。:after伪类元素实现元素末尾添加一个看不见的块元素1234567#parent:after&#123; content:"."; height:0; visibility:hidden; display:block; clear:both;&#125; http://www.cnblogs.com/zhongweizhu/p/6003537.html 3. 行内元素和块级元素block元素包括1&lt;div&gt;,&lt;p&gt;,&lt;h1&gt;...&lt;h6&gt;,&lt;ol&gt;,&lt;ul&gt;,&lt;dl&gt;,&lt;table&gt;,&lt;address&gt;,&lt;blockquote&gt;,&lt;form&gt; 特点：1.每个块级元素都是独自占一行，其后的元素也只能另起一行。2.元素的高度、宽度、行高和顶底边距都是可以设置的。3.元素的宽度如果不设置的话，默认为父元素的宽度。 inline元素包括1&lt;a&gt;,&lt;b&gt;,&lt;br&gt;,&lt;code&gt;,&lt;em&gt;,&lt;font&gt;,&lt;i&gt;,&lt;img&gt;,&lt;input&gt;,&lt;label&gt;,&lt;small&gt;,&lt;span&gt;,&lt;strong&gt;,&lt;sub&gt;,&lt;sup&gt;,&lt;textarea&gt;,&lt;u&gt; 特点：1.可以和其他行内元素一行。2.元素的高度、宽度和顶部及底部边距不可设置。3.元素的宽度就是它包含的内容、图片的宽度，不可改变。 行内元素和块级元素的转换：1.块级元素-&gt;行内元素 :display:inline2.行内元素-&gt;块级元素 ：display:block 如果向设置高度、宽度、行高及顶底边距，又想元素处于一行，可以设置display:inline-block 行内元素和块级元素的区别：(1) 行内元素同一行水平排列。块级元素各占一行，垂直方法排列。(2) 块级元素可以包含行内元素和块级元素，但行内元素不能包含块级元素。(3) 行内元素与块级元素的属性不同，主要是在盒模型属性上。(4) 行内元素设置width无效，height无效（可以设置line-height），margin上下无效，padding上下无效，水平margin和padding有效，宽度取决于内容的宽度。 4. 闭包5. http状态码，304原理6. 跨域7. 依次每隔两秒输出[1,2,3,4,5]8. Array.map()方法9. 字符串翻转10. 如何判断单链表的环？优化？11. let和var的区别（变量提升）12. 快速排序算法思路，时间复杂度13. 在学习过程中遇到什么问题，怎么解决的]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>js面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-前端安全（XSS,CSRF攻击技术）]]></title>
    <url>%2F2017%2F08%2F15%2Fjavascript-Safety%2F</url>
    <content type="text"><![CDATA[简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击目标。在Web应用中，从浏览器那接收到的HTTP请求的全部内容，都可以在客户端自由地变更、篡改。所以Web应用可能会接收到与预期数据不相同的内容。在HTTP请求报文内加载攻击代码，就能发起对Web应用的攻击。通过URL查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，若这时Web应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。在web网页的脚本中，有些部分的显示内容会依据外界输入值而发生变化，而如果这些声称html的程序中存在问题，就会滋生名为跨站脚本的安全隐患Web应用程序中，如果存在XSS漏洞，就会有以下风险：1、用户的浏览器中运行攻击者的恶意脚本，从而导致库kit信息被窃取，攻击者就会假冒用户的信息进行登录。2、攻击者能够获取用户的权限，来恶意使用web应用的功能。3、可以向用户使用伪造的数据表单，通过钓鱼的方式来窃取用户的个人信息。也就是我们这里讲到的主要的钓鱼攻击和盗取cookie XSSXss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法1.代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。2.避免直接在cookie 中泄露用户隐私，例如email、密码等等。3.通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。4.尽量采用POST 而非GET 提交表单 CSRFCSRF（Cross-site request forgery），中文名称：跨站请求伪造。你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 CSRF攻击攻击原理及过程 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 CSRF漏洞检测 检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。 防御CSRF攻击 验证HTTP Referer字段 在请求地址中添加token并验证 在HTTP头重自定义属性并验证 XSS与CSRF有什么区别吗？XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1.登录受信任网站A，并在本地生成Cookie。 2.在不登出A的情况下，访问危险网站B。 CSRF的防御1.服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。2.使用验证码]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>前端攻击技术，XSS</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-HTTP与HTTPS]]></title>
    <url>%2F2017%2F08%2F11%2Fjavascript-HTTP-HTTPS%2F</url>
    <content type="text"><![CDATA[为什么使用http2.0 慢影响一个网络请求的因素主要有两个，带宽和延迟。大部分时候都是延迟在影响响应速度。 连接无法复用连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动对文件类大的请求影响较大。 head of line blockinghead of line blocking会导致贷款无法被充分利用。 http2.0 VS http1.1 多路复用多路复用通过多个请求stream共享一个tcp连接的方式，解决了http1.x holb（head of line blocking）的问题，降低了延迟同时提高了带宽的利用率。 压缩头部HTTP/2.0规定了在客户端和服务器端会使用并且维护「首部表」来跟踪和存储之前发送的键值对，对于相同的头部，不必再通过请求发送，只需发送一次。事实上,如果请求中不包含首部（例如对同一资源的轮询请求），那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP2.0的连接存续期内始终存在,由客户端和服务器共同渐进地更新。 二进制分帧在应用层与传输层之间增加一个二进制分帧层，以此达到“在不改动HTTP的语义，HTTP 方法、状态码、URI及首部字段的情况下，突破HTTP1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。”在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。 请求优先级多路复用导致所有资源都是并行发送，所以需要优先级的概念，这样可以对重要文件进行先传输，加速页面的渲染。 服务器推送服务器推送是指客户端请求之前发送数据的机制。 HTTPHTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS工作原理客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。（5）Web服务器利用自己的私钥解密出会话密钥。（6）Web服务器利用会话密钥加密与客户端之间的通信。 HTTPS的优点尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 HTTP 与HTTPShttp是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)]]></title>
    <url>%2F2017%2F08%2F10%2Fjavascript-howtoshowhtml%2F</url>
    <content type="text"><![CDATA[从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)记忆：输URL、查缓存、解析URL、HTTP请求报文、获取IP、建立TCP连接、发送请求、解析请求、缓存是否新鲜304、返回响应报文、关闭TCP、浏览器检查状态码、缓存资源、解码、解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本。 1、输入地址 当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于google的chrome的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。 2、浏览器查找域名的 IP 地址 1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。 2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。 3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。 4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。 5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。 6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。下面这张图很完美的解释了这一过程： —-知识扩展—- 1)什么是DNS？ DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。 2)DNS查询的两种方式：递归查询和迭代查询 1、递归解析当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。 2、迭代解析 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5。 3)DNS域名称空间的组织方式 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例 4)DNS负载均衡 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 3、浏览器向 web 服务器发送一个 HTTP 请求 拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。 TCP连接如图所示: 建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。 客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分： 请求方法URI协议/版本请求头(Request Header)请求正文：下面是一个完整的HTTP请求例子：123456789GET/sample.jspHTTP/1.1Accept:image/gif.image/jpeg,*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=jinqiao&amp;password=1234 注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 （1）请求的第一行是“方法URL议/版本”：GET/sample.jsp HTTP/1.1（2）请求头(Request Header) 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。123456Accept:image/gif.image/jpeg.*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)Accept-Encoding:gzip,deflate. （3）请求正文请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息： username=jinqiao&amp;password=1234 —- 知识扩展—- 1）TCP三次握手 第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认；第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。如图所示： 2）为什需要三次握手？ 《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。 假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。 3）TCP四次挥手 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与- SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 4）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 4、服务器的永久重定向响应 服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问http://www.google.com/ 而非http://google.com/。 为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。 —-扩展知识—- 1）301和302的区别。 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301 2）重定向原因：（1）网站调整（如改变网页目录结构）；（2）网页被移到一个新地址；（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 3）什么时候进行301或者302跳转呢？ 当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。清晰明确而言：使用301跳转的大概场景如下： 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。空间服务器不稳定，换空间的时候。 5、浏览器跟踪重定向地址现在浏览器知道了 “http://www.google.com/&quot;才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的 6、服务器处理请求 经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？ 后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 如图所示： 通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。 —-扩展阅读—- 1）什么是反向代理？ 客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 7、服务器返回一个 HTTP 响应 经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是： 状态行响应头(Response Header)响应正文123456789101112HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122＜html＞＜head＞＜title＞http＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞ 状态行：状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。格式: HTTP-Version Status-Code Reason-Phrase CRLF例如: HTTP/1.1 200 OK \r\n| -协议版本：是用http1.0还是其他版本| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。 100 Continue101 Switching Protocols2xx：成功状态码，表示服务器已成功接收到请求并进行处理。 200 OK 表示客户端请求成功204 No Content 成功，但不返回任何实体的主体部分206 Partial Content 成功执行了一个范围（Range）请求3xx： 重定向状态码，表示服务器要求客户端重定向。 301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现4xx：客户端错误状态码，表示客户端的请求有非法内容。 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因404 Not Found 请求的资源不存在，例如，输入了错误的URL5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常响应头： 响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有： 响应正文包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文： 8、浏览器显示 HTML 在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括： 解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树 浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。 解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。 DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。 页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。 当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。 JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。 JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。具体的过程可以看我这篇文章：点击这里 9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：图片：http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gifCSS式样表：http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.cssJavaScript 文件：http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js 这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中 https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>浏览器地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-跨域]]></title>
    <url>%2F2017%2F08%2F09%2Fjavascript-cross-domain%2F</url>
    <content type="text"><![CDATA[javascript的同源策略何为同源URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。 同源策略的含义脚本只能读取和所属文档来源相同的窗口和文档的属性。 为什么要有同源限制？我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手。 跨域只要协议、域名、端口有任何一个不同，都被当作是不同的域。 解决跨域的方法 1. 跨域资源共享(CORS)定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。 基本思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败服务器端对于CORS的支持，主要就是通过设置 12345&lt;script type="text/javascript"&gt; var xhr = new XMLHttpRequest(); xhr.open("￼GET", "/trigkit4",true); xhr.send();&lt;/script&gt; 上面是使用了相对路径，如果用CORS，则代码如下12345&lt;script type="text/javascript"&gt; var xhr = new XMLHttpRequest(); xhr.open("￼GET", "http://segmentfault.com/u/trigkit4/",true); xhr.send();&lt;/script&gt; 把相对路径换成了其他域的绝对路径，也就是要跨哟访问的接口地址。Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 2. 通过jsonp跨域jsonp也叫填充式JSON,是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON。 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。JSONP通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求，格式要求严格。JSONP由两部分组成：回调函数和数据。回调函数是当响应来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的 123456&lt;script type="text/javascript"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt; js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。 优点:它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 缺点：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 CORS与JSONP对比CORS与JSONP相比，无疑更为先进、方便和可靠。 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS。 3. 通过修改document.domain来跨子域将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域主域相同的使用document.domain。修改document.domain的方法只适用于不同子域的框架间的交互。 4. 使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。 5. 使用HTML5的window.postMessage方法跨域window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。 借鉴了https://segmentfault.com/a/1190000000718840]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>同源</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-内存泄漏]]></title>
    <url>%2F2017%2F08%2F09%2Fjavascript-MemoryLeak%2F</url>
    <content type="text"><![CDATA[什么叫内存泄漏不再用到的内存，没有及时释放，就叫做内存泄漏。 哪些操作会造成内存泄漏？ setTimeout 的第一个参数使用字符串而非函数的话,会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时,就会产生一个循环） 全局变量引起的内存泄漏解决办法： 使用严格模式’use strict’ DOM清空或删除，事件未清除导致的内存泄露 子元素存在引用引起的内存泄漏 被遗忘的计时器或回调函数解决办法：removeEventListener()，现状的浏览器可以正确检测和处理循环引用。 javascript垃圾回收方法 标记清除（mark and sweep）这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting)在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-同步与异步(Ajax，promise)]]></title>
    <url>%2F2017%2F08%2F08%2Fjavascript-synchronization-asynchronism%2F</url>
    <content type="text"><![CDATA[同步代码依次执行。脚本会停留并等待服务器发送回复然后再继续。 异步脚本允许页面继续其进程并处理可能的回复 setTimeout()与setInterval()setTimeout和setInterval可以改变一个队列函数的执行顺序. AjaxAjax 是异步Javascript和XML，用于在Web页面中实现异步数据交互 Ajax优点：（1）使得页面不重载全部内容的情况下加载局部内容，降低数据传输量（2）避免用户不断刷新或者跳转页面，提高用户体验 Ajax过程(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.(3)设置响应HTTP请求状态变化的函数.(4)发送HTTP请求.(5)获取异步调用返回的数据.(6)使用JavaScript和DOM实现局部刷新. Ajax原生js代码123456789101112131415function loadXMLDoc(url) &#123; var xmlhttp; // 1.创建XMLHttpRequest对象 if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp = new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; document.getElementById('p1').innerHTML = xmlhttp.responseText; &#125; &#125; xmlhttp.open("GET", url, true); xmlhttp.send();&#125; Ajax方法1.open(method,url,async) 规定请求类型、URL以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） 2.send(string)将请求发送到服务器。string：仅用于 POST 请求 Ajax请求中的get方式和post方式与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 Get是通过地址栏来传值，而Post是通过提交表单来传值。 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据。setRequestHeader(header,value)向请求添加 HTTP 头。header: 规定头的名称value: 规定头的值 XMLHttpRequest响应 responseText获得字符串形式的响应数据。 responseXML获得XML形式的响应数据。 XMLHttpRequest.onreadystatechange事件每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status 200:”OK” 404:未找到页面 promisepromise定义ES6 原生提供了 Promise 对象。所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作）.Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 promise的特点（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Fulfilled（已成功）和Rejected（已失败）。（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Fulfiled和从Pending变为Rejected。 promise对象的使用promise的构造函数1234567var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 promise实例的then()方法12345promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 promise对象实现Ajax操作的例子1234567891011121314151617181920212223242526272829var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;);]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Ajax</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-正则表达式]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-RegularExpression%2F</url>
    <content type="text"><![CDATA[用正则表达式验证邮箱格式123456789function(emailAddress) &#123; var str = '^[A-Za-z\d]+([-_.][A-Za-z\d]+)*@([A-Za-z\d]+[-.])+[A-Za-z\d]&#123;2,4&#125;'; var re = new RegExp(str); //创建正则表达式对象 if(str.test(emailAddress)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 正则表达式符号^ 匹配一个输入或一行的开头，/^a/匹配”an A”，而不匹配”An a”$ 匹配一个输入或一行的结尾，/a$/匹配”An a”，而不匹配”an A”(x) 匹配x保存x在名为$1…$9的变量中x|y 匹配x或y{n} 精确匹配n次{n,} 匹配n次以上{n,m} 匹配n-m次[xyz] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符)[^xyz] 不匹配这个集合中的任何一个字符\w 匹配一个可以组成单词的字符，相当于[a-zA-Z0-9]，匹配大小写字母和数字 量词* 匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa+ 匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa? 匹配前面元字符0次或1次，/ba？/将匹配b,ba RegExp对象的方法test():检索字符串中指定的值。返回 true 或 false。exec()检索字符串中指定的值。返回找到的值，并确定其位置。 用正则表达式验证URL1^((https|http|ftp|rtsp|mms)?:\/\/)+[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&amp;_~`@[\]\':+!]*([^&lt;&gt;\"\"])*]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-线程与进程]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-thread-process%2F</url>
    <content type="text"><![CDATA[一个程序至少有一个进程,一个进程至少有一个线程. 进程（process）是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为一些功能单元。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-setTimeOut()与setInterval()]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-setTimeOut-setInterval%2F</url>
    <content type="text"><![CDATA[Javascript用来处理延时和定时任务的setTimeOut和setInterval函数应用非常广泛，它们都用来处理延时和定时任务，比如打开网页一段时间后弹出一个登录框，页面每隔一段时间发送异步请求获取最新数据等等。 setTimeOut() setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式 setTimeout()只执行一次 第一个参数是要执行的code或句柄，第二个是延迟的毫秒数。 用法 1var timeoutID = window.setTimeout(func, [delay, param1, param2, ...]); var timeoutID = window.setTimeout(code, [delay]); clearTimeOut()函数用来清除定时器 实例 12345for(var i=1;i&lt;=3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0);&#125;; 输出4，4，4原因：Javascript事件处理器在线程空闲之前不会运行。那么问题来了，如何让上述代码输出1 2 3？12345for(var i=1;i&lt;=3;i++)&#123; setTimeout((function(a)&#123; //改成立即执行函数 console.log(a); &#125;)(i),0);&#125;; setInterval() setInterval()是在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval()把它清除 第一个参数是要执行的code或句柄，第二个是延迟的毫秒数。 写一个递归，每隔5秒调用自身，一共100次。12345678var counter = 0;var timer = setInterval(function() &#123; alert('test'); counter++; if(counter == 100) &#123; clearInterval(timer); &#125;&#125;,5000);]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>setTimeout()</tag>
        <tag>setInterval()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-基本数据类型]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-DataType%2F</url>
    <content type="text"><![CDATA[六种基本数据类型 undefined: 一个未初始化的变量的值为undefined; 一个没有传入实参的形参变量的值为undefined; 如果一个函数什么都不返回,则该函数默认返回undefined; null: 没有对象被呈现 string: boolean: number: sysbol(ES6): null与undefined的不同点 null是一个字面量（而不是全局对象的一个属性,undefined 是）; null是一个表示”无”的对象, Number(null) == 0；undefined是一个表示”无”的原始值, Number(undefined) == NaN。 当声明的变量还未被初始化时,变量的默认值为undefined。 null用来表示尚未存在的对象,常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义。典型用法是： （1）变量被声明了,但没有赋值时,就等于undefined。（2） 调用函数时,应该提供的参数没有提供,该参数等于undefined。 （3）函数没有返回值时,默认返回undefined。 （4）对象没有赋值的属性,该属性的值为undefined。 null表示”没有对象”,即该处不应该有值。典型用法是： （1） 作为函数的参数,表示该函数的参数不是对象。 （2） 作为对象原型链的终点。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-事件流，事件代理]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-EventFlow%2F</url>
    <content type="text"><![CDATA[事件流事件流模型冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="outer"&gt; &lt;div id="inner"&gt; Click me! &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在冒泡型事件流click事件的传播顺序为：inner-&gt;outer-&gt;body-&gt;html-&gt;document 在捕获型事件流click事件的传播顺序为：document-&gt;html-&gt;body-&gt;outer-&gt;inner DOM事件流DOM事件流采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。 事件捕获阶段：实际目标在捕获阶段不会接收事件。也就是在捕获阶段。上图中为1~3. 处于目标阶段：事件上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。 冒泡阶段：事件又传播回文档。 在DOM事件流中，实际的目标inner在捕获阶段不会接受到事件。这意味着在捕获阶段，事件到outer就停止了，下一个阶段是“处于目标”阶段，于是事件在inner 上发生，并在事件处理中被看成是冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 DOM2级事件定义了两个方法用于处理置顶和删除事件处理程序的操作addEventListener()和removeEventListener()，所有DOM节点都包含这两个方法，并且它们都接受3个参数：要处理的事件名，作为事件处理的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序，反之则是在事件冒泡阶段处理程序。DOM2级方法添加事件处理程序的好处是可以添加多个事件处理程序，会按照添加顺序被处理（无论是捕获还是冒泡）。而IE不同的它有自己的方法attachEvent()和detachEvent,这两个接受相同的两个参数：事件处理程序名称和事件处理程序函数。 DOM2级事件定义了两个方法用于处理置顶和删除事件处理程序的操作addEventListener()和removeEventListener()，所有DOM节点都包含这两个方法，并且它们都接受3个参数：要处理的事件名，作为事件处理的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序，反之则是在事件冒泡阶段处理程序。DOM2级方法添加事件处理程序的好处是可以添加多个事件处理程序，会按照添加顺序被处理（无论是捕获还是冒泡）。 IE的事件流IE没有提供对事件捕获的支持，所以IE跟标准浏览器对DOM事件流实现不一样。而IE不同的它有自己的方法attachEvent()和detachEvent,这两个接受相同的两个参数：事件处理程序名称和事件处理程序函数。 添加和删除事件监听器：w3c： addEventListener/ removeEventListener()IE: attachEvent()/ detachEvent() 事件监听：IE事件监听器使用全局的Event对象，而w3c将event对象作为参数传递给监听器123function handler（event）&#123; event = event || window.event;&#125; 阻止冒泡：IE： e.cancelBubble=true;w3c：e.stopPropagation(); attachEvent 与addEventListener区别一、适应的浏览器版本不同二、attachEvent中的事件带on，而addEventListener中的事件不带on三、参数的个数不同attachEvent()，只有冒泡；addEventListener(事件名称,接收事件处理的函数,bool值) 默认为false，事件句柄在冒泡阶段执行，true在捕获阶段。 event.stopPropagation(); 支持FF=&gt; 停止传播event.cancelBubble = true; 支持IE =&gt; 取消冒泡 自动执行点击事件，兼容IE12345678910111213141516171819202122window.onload = function() &#123; var btn = document.getElementById('my-btn'); var handler = function() &#123; alert(this.tagName); &#125; if (btn.addEventListener) &#123; // 调用的处理程序使用事件目标作为它们的this值 // 此处也可以传递e事件：handler(e); e.target.tagName btn.addEventListener("click", handler, false); &#125; else if (btn.attachEvent) &#123; // 注册的处理程序作为函数调用，它们的this值是全局（window）对象 // 此处也可以传递e事件：handler(e); e.srcElement.tagName btn.attachEvent("onclick", handler.call(btn)); &#125; if (document.all) &#123; btn.click(); &#125; else &#123; var evt = document.createEvent("MouseEvents"); evt.initEvent("click", true, true); btn.dispatchEvent(evt); &#125;;&#125; 事件代理事件代理的原理事件代理的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。 传统事件处理做法是为每个元素添加事件处理器。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; (function()&#123; var colorList=document.getElementById("color-list"); var colors=colorList.getElementsByTagName("li"); for(var i=0;i&lt;colors.length;i++) &#123; colors[i].addEventListener('click',showColor,false); &#125;; function showColor(e) &#123; e=e||window.event; var targetElement=e.target||e.srcElement; alert(targetElement.innerHTML); &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt; 事件代理的处理方式是： 12345678910111213141516171819202122232425&lt;body&gt; &lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; (function()&#123; var colorList=document.getElementById("color-list"); colorList.addEventListener('click',showColor,false); function showColor(e) &#123; e=e||window.event; var targetElement=e.target||e.srcElement; if(targetElement.nodeName.toLowerCase()==="li")&#123; alert(targetElement.innerHTML); &#125; &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt; 事件代理的好处 将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。 DOM更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。 事件代理的问题事件代理同时绑定了li和span，当点击span的时候，li和span都会冒泡。1234567891011&lt;li&gt;&lt;span&gt;li中的span的内容&lt;/span&gt;&lt;/li&gt;&lt;script&gt; $(document).on('click', 'li', function(e)&#123; alert('li li'); &#125;); $(document).on('click', 'span', function(e)&#123; alert('li span'); &#125;)&lt;/script&gt; 解决办法： span的事件处理程序中阻止冒泡 1234$(document).on('click', 'span', function(e)&#123; alert('li span'); e.stopPropagation();&#125;) li的事件处理程序中检测target元素 1234567$(document).on('click', 'li', function (e) &#123; if (e.target.nodeName == 'SPAN') &#123; e.stopPropagation(); return; &#125; alert('li li');&#125;);]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>事件流</tag>
        <tag>事件代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-localsearch本地搜索]]></title>
    <url>%2F2017%2F08%2F07%2Fhexo-localsearch%2F</url>
    <content type="text"><![CDATA[在git bash上输入npm install hexo-generate-search –save 再安装npm install hexo-generate-searchdb –save 在主题目录下的配置文件_config.yml中修改1234567local_search: enable: true //改为true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>本地搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-数组-字符串方法]]></title>
    <url>%2F2017%2F08%2F06%2Fjavascript-Array-String%2F</url>
    <content type="text"><![CDATA[Array数组 concat()用途 用于连接两个或多个数组，返回被连接的数组。 语法 arrayObject.concat(arrayX,arrayY) 实例12var arr = ['A', 'B', 'C'];var arr2 = [1,2,3]; arr.concat(arr2);//['A','B','C','D',1,2,3],arr并没有被修改 pop()用途 删除并返回最后一个元素 语法 arrayObject.pop() 实例12var arr = ['A', 'B', 'C'];arr.pop();//arr=['A','B'] push()用途 向数组尾部添加一个或更多元素，返回新的长度。 语法 arrayObject.push(elment1,element2…) 实例12var arr = ['A', 'B', 'C'];arr.push('J','K');//['A','B','C','J','K'] shift()用途 删除并返回数组的第一个元素 实例12var arr = ['A', 'B', 'C'];arr.shift();//['B','C'] slice()用途 截取数组的部分长度，然后返回新的数组 实例123arr.slice(0,2);//从开始索引0开始，到结束索引结束，但不包括结束索引，['A','B']arr.slice(2);//从开始到结束，['D'] splice()用途 向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组 语法 arrayObject.splice(index,howmany,item1,item2…) 实例123456var arr = [1,2,3,4,5];arr.splice(2,0,6); // arr=[1,2,6,3,4,5]在下标为2的位置上添加，0表示添加，返回[]arr.splice(2,1,7);// arr=[1,2,7,3,4,5]在下标为2的位置上删除该元素并替换成7，1代表删除，返回[6]arr.splice(1,3); //arr=[1,4,5],返回被删除的元素[2,7,3]arr.splice(1,2,6,8);//arr=[1,6,8]，返回被删除的元素[4,5] unshift()用途 向数组头部添加一个或更多元素，并返回新的长度。 实例12var arr = [1,2,3,4,5];arr.unshift(6,7);//返回新长度3，arr=[6,7,1,2,3,4,5] indexOf()用途 搜索一个指定元素的位置 实例12var arr = [1,2,3,4,5];arr.indexOf(2); // 1 forEach()用途对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。 实例12345678910var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123; console.log(x + '|' + index + '|' + (a === arr));&#125;);// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true map()用途指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 实例12345var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item)&#123; return item*item;&#125;);console.log(arr2); //[1, 4, 9, 16, 25] String charAt()用途 返回在指定位置的字符 实例12var s = 'abcdef';s.charAt(3);// d indexOf()用途 返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。 语法 strObj.indexOf(substr[,startIndex]) 实例12var str = "ABCDECDF";str.indexOf("CD"，1); // 由1位置从左向右查找 123... 返回2 slice()用途 返回字符串片段。 语法strObj.slice(start[,end])start下标从0开始的strObj指定部分其实索引。如果start为负，将它作为length+start处理，此处length为字符串的长度。end下标从0开始的strObj指定部分结束索引。如果end为负，将它作为length+end处理，此处length为字符串的长度。 实例12var str = "ABCDEF";str.slice(2,4); //第2个参数为&lt;end的下标，返回CD split()用途 把一个字符串分割成字符串数组 语法stringObject.split(separator,howmany) 实例12var str="How are you doing today?"console.log(str.split(" ")); // How,are,you,doing,today? substr()用途抽取从 start 下标开始的指定数目的字符 语法stringObject.substr(start,length) 实例12var str = "hello world";console.log(str.substr(3,4));// lo w substring()用途提取字符串中介于两个指定下标之间的字符。 语法stringObject.substring(start,stop) 实例12var str = "hello world";console.log(str.substring(3,5));// lo]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-New关键字]]></title>
    <url>%2F2017%2F08%2F06%2Fjavascript-New%2F</url>
    <content type="text"><![CDATA[new操作符具体干了什么呢？12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;;// (1) o.__proto__=Person.prototype; //(2)原型继承 Person.call(o,name);// (3) return o;// (4)&#125;var personB=person("xl");console.log(personB.name); // 输出 xl (1)新建一个空对象o；(2)设置原型链，将o的__proto__指向Person.prototype,完成对Person的原型对象的属性和方法的继承；(3)让Person中的this指向o；(4)返回对象o。此时调用person()函数就相当于new Person()。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-This关键字]]></title>
    <url>%2F2017%2F08%2F06%2Fjavascript-This%2F</url>
    <content type="text"><![CDATA[谁调用这样函数或方法，this关键字就指向谁。在JS中，函数调用的方式有 普通函数调用 作为方法来调用 作为构造函数调用 使用apply/call方法来调用 Function.prototype.bind()方法 es6箭头函数 普通函数调用 1234567function person()&#123; this.name="xl"; console.log(this); console.log(this.name);&#125;person(); //输出 window xl 相当于person()作为全局变量window的一个方法来调用，相当于window.person()，所以this志向window. 作为方法来调用 1234567891011var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xlvar showNameA=person.showName;showNameA(); //输出 XL 1.这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出”Xl”.2.这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window. 作为构造函数来调用 12345678910function Person(name)&#123; this.name=name;&#125;var personA=Person("xl");console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xlvar personB=new Person("xl");console.log(personB.name);// 输出 xl//这部分代码的解释见下 1.上面代码没有进行new操作，相当于window对象调用Person(“xl”)方法，那么this指向window对象，并进行赋值操作window.name=”xl”. new操作符12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;; o.__proto__=Person.prototype; //原型继承 Person.call(o,name); return o;&#125;var personB=person("xl");console.log(personB.name); // 输出 xl 1.首先在person里创建空对象o，将o的__proto__指向Person.prototype,完成对Person的原型对象的属性和方法的继承；2.Person.call(o,name)表示将Person对象中的this指向o，即o.name=name;3.返回对象o。 call/apply方法的调用 call/apply方法最大的作用就是改变this的指向。Obj.method.apply(AnotherObj,arguments);123456789var name="XL";var Person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;Person.showName.call(); //输出 "XL"Person.showName();// 输出“Xl” call()不带参数是指向window，若带参数，this指向第一个参数。 Function.prototype.bind()方法 1234567891011var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;,50) &#125;&#125;var person=new Person("xl");person.sayName() //输出 “my name is XL”; setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL1234567891011var name="XL"; function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;.bind(this),50) //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象 &#125; &#125; var person=new Person("xl"); person.sayName(); //输出 “my name is xl”; 这里setTimeout(function(){console.log(this.name)}.bind(this),50);,匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向的Person,而非window,因此最后的输出为”my name is xl”而不是”my name is XL” setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined Eval()函数 该函数执行时，this绑定到当前作用域的对象上。123456789101112var name="XL";var person=&#123; name:"xl", showName:function()&#123; eval("console.log(this.name)"); &#125;&#125;person.showName(); //输出 "xl"var a=person.showName;a(); //输出 "XL" es6箭头函数 箭头函数的 this 始终指向函数定义时的 this，而非执行时。12345678910var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(() =&gt; &#123; this.func() &#125;, 100); // this指向o &#125;&#125;;o.test();// 1 借鉴了[https://segmentfault.com/a/1190000003046071]]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-继承]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Inherit%2F</url>
    <content type="text"><![CDATA[概述 继承方式原型链继承 思想为了让子类继承父类的属性，首先需要定义一个构造函数。然后将父类的新实例赋值给构造函数的原型对象。 代码示例12345678910111213function Parent()&#123; this.name = 'mike'; &#125; function Child()&#123; this.age = 12; &#125; Child.prototype = new Parent();//Child继承Parent，通过原型，形成链条，核心代码 var test = new Child(); alert(test.age); alert(test.name);//得到被继承的属性 alert(test instanceof Child); //确定原型对象和实例的关系。 特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例； 父类新增原型方法/属性，子类能访问到； 简单，易于实现。 缺点 想为子类新增方法和属性，必须在 new Parent()这样的语句之后执行，不能放到构造函数中； 无法实现多继承； 来自原型对象的引用属性是所有实例共享的；（致命） 创建子类实例时，无法向父类构造函数传参。（致命） 构造继承 思想在子类构造函数的内部调用超类的构造函数，通过call()和apply()方法可以在创建的对象上执行构造函数。（没用到原型） 代码示例1234567891011function SuperType() &#123; this.colors = ["red","blue","green"];&#125;function SubType() &#123; SuperType.call(this);//继承了SuperType，核心代码&#125;var instance1 = new SubType();instance1.colors.push("black");console.log(instance1.colors);//"red","blue","green","black"var instance2 = new SubType();console.log(instance2.colors);//"red","blue","green" 特点 解决了原型链继承中，子类实例共享父类引用的属性问题； 创建子类型时，可以向父类传递参数； 可以实现多继承 缺点 实例并不是父类的实例，只是子类的实例； 只能继承父类实例的属性和方法，不能继承原型对象的属性和方法；（没有用到原型链） 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能。（致命，原型链可复用） 组合继承（最常用） 思想使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。通过Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Sub.prototype = new Super();继承父类函数，实现函数复用。 代码示例1234567891011121314151617181920212223242526function SuperType(name) &#123; this.name = name; this.colors = ["red","blue","green"];&#125;SuperType.prototype.sayName = function() &#123;co nsole.log(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this,name);//使用构造函数继承属性，核心代码 this.age = age;&#125;//继承方法SubType.prototype = new SuperType();// 使用原型链继承原型对象的SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;var instance1 = new SubType("EvanChen",18);instance1.colors.push("black");console.log(instance1.colors);//"red","blue","green","black"instance1.sayName();//"EvanChen"instance1.sayAge();//18var instance2 = new SubType("EvanChen666",20);console.log(instance2.colors);//"red","blue","green"instance2.sayName();//"EvanChen666"instance2.sayAge();//20 特点 不存在引用属性共享问题 可传参给父对象 函数可复用 缺点 父类的构造函数被引用了两次 原型式继承 思想 继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式。 代码示例1234567891011121314151617181920212223// 核心模块function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var box = &#123; name : 'trigkit4', arr : ['brother','sister','baba']&#125;;var b1 = obj(box);alert(b1.name);//trigkit4b1.name = 'mike';alert(b1.name);//mikealert(b1.arr);//brother,sister,babab1.arr.push('parents');alert(b1.arr);//brother,sister,baba,parentsvar b2 = obj(box);alert(b2.name);//trigkit4alert(b2.arr);//brother,sister,baba,parents 特点从已有对象衍生新对象不需要创建自定义类型 缺点 原型引用属性会被所有实例共享，因为是用整个父类对象来充当子类的原型对象。 无法实现代码复用 寄生式继承 思想创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。创建新对象-&gt;增强-&gt;返回该对象 寄生组合式继承（最完美） 思想通过寄生方式，去掉父类的实例属性，这样，在调用两次父类的构造函数时，就不会初始化两次实例方法/属性，避免组合继承的缺点。 代码示例123456789101112131415161718192021222324252627282930313233343536373839// 原型式继承代码function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; // 创建对象-&gt;增强对象-&gt;返回对象，核心代码 function create(parent,child)&#123; var f = obj(parent.prototype);//创建对象 f.constructor = child;//增强对象 child.prototype = f; return f; &#125; function Parent(name)&#123; this.name = name; this.arr = ['brother','sister','parents']; &#125; Parent.prototype.run = function () &#123; return this.name; &#125;; function Child(name,age)&#123; Parent.call(this,name);//构造函数 this.age =age; &#125; create(Parent,Child);//通过这里实现继承 var test = new Child('trigkit4',21); test.arr.push('nephew'); console.log(test.arr);//["brother", "sister", "parents", "nephew"] console.log(test.age);// 21 console.log(test.run());//trigkit4 var test2 = new Child('jack',22); console.log(test2.age);// 22 console.log(test2.arr);//["brother", "sister", "parents"] 特点完美]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-原型链]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Prototype%2F</url>
    <content type="text"><![CDATA[普通对象与函数对象 凡是通过new Function()创建的对象都是函数对象，其他的都是普通对象。 构造函数 实例的属性（constructor）指向构造函数。 原型对象 函数对象(构造函数)都有prototype属性，指向函数的原型对象。每个对象都有__proto__属性，但只有函数对象才有prototype。 在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）属性，这个属性指向prototype属性所在的函数（Person） 12Person.prototype.constructor == Person;person1.constructor == Person; 原型对象（Person.prototype）是构造函数（Person）的一个实例。原型对象是用来继承的。 __proto__ 对象都有__proto__的内置属性，指向创建它的构造函数的原型对象。person1.__proto__== Person.protoype1234567891011var b = new Array();b.constructor === Array;b.__proto__ === Array.prototype;var c = new Date();c.constructor === Date;c.__proto__ === Date.prototype;var d = new Function();d.constructor === Function;d.__proto__ === Function.prototype; 所有函数对象的__proto__都指向Function.prototype，它是一个空函数。12345678910111213141516171819202122232425262728Number.__proto__ === Function.prototype // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype // trueError.constructor == Function //trueDate.__proto__ === Function.prototype // trueDate.constructor == Function //true Math和JSON无需new12345Math.__proto__ === Object.prototype // trueMath.construrctor == Object // trueJSON.__proto__ === Object.prototype // trueJSON.construrctor == Object //true 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind。Function.prototype是唯一一个typeof XXX.prototye为function的prototype，其它的构造器的prototype都是object1Object.prototype.__proto__ === null // true 原型链的基本思路 利用原型让引用类型继承另一个引用类型的属性和方法。每隔构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（construrctor），而实例对象都包含一个指向源性对象的内部指针(__proto__)，如果让原型对象等于另一个类型的实例，此时的原型对象将包含另一个原型的指针(__proto__)，另一个原型也包含着一个指向另一个构造函数的指针（construrctor），构成了实例和原型的链条。 总结 所有函数对象的__proto__都指向Function.prototype，是一个空函数。 所有对象的__proto__都指向其构造函数的prototype。 每个对象都有construrctor属性，指向构造函数。 person1.__proto__==Person.protype==person1.construrctor.prototype Object.prototype.__proto__ == null 原型链存在于实例和构造函数的原型对象之间，即 person1.__proto__ == Person.prototype 本文借鉴了[http://www.jianshu.com/p/dee9f8b14771]，http://blog.csdn.net/sinat_21274091/article/details/52741788]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-作用域链]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Scope%2F</url>
    <content type="text"><![CDATA[定义 作用域：是一个“地盘”，一个抽象概念，其中没有变量，要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。作用域中变量的值是执行过程中产生的确定的，而作用域是在函数创建时就确定了。 要查询一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会又冲突。 函数作用域1234567var scope="global"; function t()&#123; console.log(scope); // undefined var scope="local" console.log(scope); // "local"&#125; t(); javascript没有块级作用域，有函数作用域函数作用域:变量在声明它们的函数体以及这个函数嵌套的任意函数体内都是有定义的。javascript没有块级作用域，如下：123456var name="global"; if(true)&#123; var name="local"; console.log(name); // "local" &#125; console.log(name); // "local" 作用域链 作用域链：作用域链的创建是在执行上下文生命周期的创建时建立的。作用域链是当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 简述作用域链 引入一大段话来解释：每一段js代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码中“作用域中”的变量。当js需要查找变量x的值的时候（这个过程称为变量解析（variable resolution）），它会从链的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中没有名为x的属性，js会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。 作用域链举例：在js最顶层代码中（也就是不包括任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域上至少有三个对象。 作用域链创建规则：当定义一个函数时（注意，是定义的时候就开始了），它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来储存它的参数或局部变量，并将这个对象添加保存至那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来说，情况又有所变化：每次调用外部函数的时候，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都要微妙的差别—在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。 可参考[http://blog.csdn.net/yueguanghaidao/article/details/9568071],]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-闭包]]></title>
    <url>%2F2017%2F08%2F04%2Fjavascript-Closure%2F</url>
    <content type="text"><![CDATA[定义闭包：有权访问另一个函数作用域中的变量的函数。 在javascript语言中，只有函数内部的子函数才能读取局部变量，所以闭包也可以理解为“定义在一个函数内部的函数”。 闭包是连接函数内部和外部的联系。 javascript的链式作用域结构，子对象会一级一级地向上寻找所有父对象的变量。所以父对象的所有变量对子对象是可见的。 闭包实例将内部函数作为返回值，就可访问函数内的变量。123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 闭包的用处 可以读取函数内部的变量； 让函数内部的变量的值保持在内存中。 123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点 由于闭包会使得函数中的变量被保存在内存中，内存消耗很大，不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是在退出函数之前，将不适用的局部变量全部删除。 闭包会在父函数外部改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，不要随便改变父函数内部变量的值。闭包的缺点闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄漏。 可参考[http://www.cnblogs.com/wangfupeng1988/p/3994065.html],[http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html]]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构(javascrit)]]></title>
    <url>%2F2017%2F08%2F02%2FData_Structure%2F</url>
    <content type="text"><![CDATA[线性表1.线性表的定义 零个或多个数据元素的有限序列。 2.线性表的分类 线性表的顺序存储结构：指的是用一段地址连续的存储单元一次存储线性表的数据元素。 线性表的链式存储结构：地址不一定连续来存储线性表的数据元素。 3.线性表的操作3.1 顺序存储3.1.1 查找元素 时间复杂度O(1) 3.1.2 插入操作思路 如果插入位置不合理，抛出异常； 如果线性表长度大于等于数组长度，则抛出异常； 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置； 将要插入元素填入位置i处； 表长加1。时间复杂度O(1). 3.1.3 删除操作思路 如果删除位置不合理，抛出异常； 取出删除元素； 从删除元素的位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置； 表长减1。时间复杂度O(1). 3.2 链式存储3.2.1 查找元素思路 声明一个结点p指向链表第一个结点； 遍历链表，指针p向后移动； 若到链表结尾p为空，则说明第i个元素不存在； 否则查找成果，返回p结点。最好时间复杂度O(1),最坏时间复杂度O(n). 3.2.2 插入元素标准代码:12s.next = p.next;p.next = s; 3.2.3 删除元素标准代码：12q = p.next;p.next = q.next; 4.单链表结构与顺序存储结构的优缺点4.1 时间性能 查找：顺序存储结构O(1),单链表O(n) 插入和删除：顺序存储结构平均时间复杂度O(n),单链表O(1) 4.2 空间性能 顺序存储结构需要预分配存储空间。单链表不需要分配存储空间。 5.单链表的分类5.1 静态链表 用数组描述的链表叫静态链表。 5.2 循环链表 将单链表中终端结点的指针由空指针改为指向头结点，头尾相连的单链表称为单循环链表。 5.3 双向链表 单循环链表增加一个指向前驱结点的指针。 插入操作 1234s.prior = p;s.next = p.next;p.next.prior = s;p.next = s; 删除操作 12p.prior.next = p.next;p.next.prior = p.prior; 栈与队列1. 定义 栈：限定仅在表尾进行插入和删除操作的线性表（后进先出） 队列：只允许在一端进行插入操作，而在另一端进行删除操作的线性表（先进先出） 2.操作2.1 栈进栈push()出栈pop() 3.分类循环队列队列满的条件是(rear+1)%QueueSize == front队列长度公式是(rear-front+QueueSize)%QueueSize 树1.定义树：是n个结点的有限集 2.相关概念度：树的度是树内各结点的度的最大值。深度：树中结点的最大层次称为树的深度。 3.树的存储结构 双亲表示法data,parent 孩子表示法data,parent,firstchild-child,next 孩子兄弟表示法data,firstchild,rightsib 4.二叉树4.1 特点 每个结点最多有两颗子树 左子树和右子树是有顺序的。 4.2 分类 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 二叉树的性质 在二叉树的第i层至多有2i-1个结点。 深度为k的二叉树至多有2k-1个结点。 对任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1。(n=n0+n1+n2,分支数总数等于结点总数减1，分支总数=n-1=n1+2n2) 具有n个结点的完全二叉树的深度为[log2n]+1. 如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i有：1.如果i=1,则结点i是二叉树的根，无双亲；如果i&gt;1,则其双亲是结点[i/2].2.如果2i&gt;n,则结点i无左孩子；否则其左孩子是结点2i。3.如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1。 4.3 二叉树的存储结构二叉链表： lchild,data,rchild 4.4 基本操作4.4.1 插入1234567891011121314151617181920212223242526272829303132333435363738/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125; function BST() &#123; this.root = null; this.insert = insert; this.inOrder = inOrder;&#125;*/ function insert(data) &#123; let node = new TreeNode(data,null,null); //插入根结点 if(this.root == null) &#123; this,root = n; &#125; else &#123; let current = this.root; let parent; while(current) &#123; parent = current; if(data&lt;current.data) &#123; current = current.left; if(current == null) &#123; parent.left = node; break; &#125; &#125; else &#123; current = current.right; if(current == null) &#123; parent.right = node; break; &#125; &#125; &#125; &#125; &#125; 4.4.2 查找最小值（最大值）1234567function getMin() &#123; let current = this.root; while(!(current.left == null)) &#123; current = current.left; &#125; return current.data;&#125; 4.4.3 查找指定值12345678910111213function find(data) &#123; let current = this.root; while(current != null) &#123; if(current.data == data) &#123; return current; &#125; else if (data&lt; current.data) &#123; current = current.left; &#125; else &#123; current = current.right; &#125; &#125; return null;&#125; 4.4.4 删除结点 删除结点有三种情况： 叶子结点，则父结点指向null 仅有左或右子树的结点，则原本指向它的结点就指向它的子结点 左右子树都有结点，则查找删除结点右结点上的最小值，将临时结点上的值复制到待删除结点，然后再删除临时结点。 1234567891011121314151617181920212223242526272829303132333435363738394041function remove(data) &#123; root = removeNode(this.root,data);&#125;//找到最小值function getMin(node) &#123; if (node.left == null) &#123; return node; &#125; else &#123; return getMin(node.left); &#125;&#125;function removeNode(node,data) &#123; if(node == null) &#123; return null; &#125; if(data == node.data) &#123; // 叶子结点 if(node.left == null &amp;&amp; node.right ==null) &#123; return null; &#125; //没有左子结点的结点 if(node.left == null) &#123; return node.right; &#125; if(node.right == null) &#123; return node.left; &#125; // 有2个子结点的结点 let tempNode = getMin(node.right); node.data = tempNode.data; node.right = removeNode(node.right,tempNode.data); return node; &#125; else if (data&lt;node.data) &#123; node.left = removeNode(node.left,data); return node; &#125; else &#123; node.right = removeNode(node.right,data); return node; &#125;&#125; 4.5 二叉树的遍历4.5.1 前序遍历 先访问根结点，然后前序遍历左子树，再前序遍历右子树。1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function PreOrderTraverse(node) &#123; if(!(node == null)) &#123; console.log(node.data); PreOrderTraverse(node.left); PreOrderTraverse(node.right); &#125;&#125; 4.5.2 中序遍历 先中序遍历左子树，访问根结点，再中序遍历右子树。1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function InOrderTraverse(node)&#123; if(!(node == null)) &#123; InOrderTraverse(node.left); console.log(node.show()); InOrderTraverse(node.right); &#125;&#125; 4.5.3 后序遍历 先后序遍历左右子树，再访问根结点。 1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function PostOrderTraverse(node)&#123; if(!(node == null)) &#123; PostOrderTraverse(node.left); console.log(node.show()); PostOrderTraverse(node.right); &#125;&#125; 4.5.4 层序遍历 从根结点开始访问，从上而下逐层遍历。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(javascript)]]></title>
    <url>%2F2017%2F07%2F21%2FSort-Function%2F</url>
    <content type="text"><![CDATA[二分查找法12345678910111213141516171819202122/* 查找条件：排好序的数组*/function binarysearch(arr, target) &#123; if(arr.length == 0) &#123; return 0; &#125; let low = 0; let high = arr.length; let mid; while(low &lt;= high) &#123; mid = Math.floor((high-low)/2); if(target == arr[mid]) &#123; return mid; &#125; else if (target &lt; arr[mid]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return 0;&#125; 1.冒泡排序法123456789101112131415161718/* 从底层开始冒泡，两两比较，小的放在前面，直到小泡泡 当数据是正序的时候最快*/function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 2.选择排序1234567891011121314151617181920/* 选择最小的元素放在前面，无论什么数据， 放进去时间复杂度都是O(n&lt;sup&gt;2&lt;/sup&gt;),好处是不需要额外内存空间*/function selectionSort(arr) &#123; const len = arr.length; let minIndex ,temp; for(let i = 0; i &lt; len-1;i++) &#123; minIndex = i; for(let j = i+1; j &lt; len; j++) &#123; if(arr[j]&lt;arr[minIndex]) &#123; //寻找最小的数 minIndex = j; // 保存最小数的索引值 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 3.插入排序法1234567891011121314151617181920212223/*1.默认第一个已经排好序2.依次将接下来的数与数组里的每个元素进行比较，若比前一个小*/function InsertSort(arr) &#123; if (arr.length == 0) &#123; return 0; &#125; let temp = 0; // 存放当前元素 for(let i = 1; i &lt; arr.length; i++) &#123; if(arr[i] &lt; arr[i-1]) &#123; temp = arr[i]; let pre = i - 1; while(pre &gt;= 0 &amp;&amp; temp &lt; arr[pre]) &#123; arr[pre+1] = arr[pre]; pre--; &#125; arr[pre+1] = temp; &#125; &#125; return arr;&#125; 4.快速排序基本思想: 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 1.在数据集之中，选择一个元素作为”基准”（pivot）。 2.所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 3.对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。123456789101112131415161718192021/** 它是由冒泡排序改进而来的。在待排序的n个记录中任取一个记录，把该记录放在合适的位置后，* 数据序列被此记录划分为两部分。所有关键字比该记录关键字小的记录放在前一部分，* 所有比它大的记录放置在后一部分，并把该记录排在这两部分的中间。*/ //交换函数 function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); //选择“基准”的索引值 var pivot = arr.splice(pivotIndex, 1)[0]; // 基准 var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(pivot, quickSort(right)); &#125;; 5.归并排序思想：两两进行比较，再归并。 归并排序的性能不受输入数据的影响，始终是O(nlogn)，代价是需要额外内存空间。123456789101112131415161718192021222324252627function mergeSort(arr) &#123; const len = arr.length; if(len&lt;2) &#123; return arr; &#125; let middle = Math.floor(len/2); let left = arr.slice(0,middle); let right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left,right) &#123; let result = [] while(left.length&gt;0 &amp;&amp; right.length&gt;0) &#123; if(left[0] &lt; right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) &#123; result.push(left.shift()); &#125; while(right.length) &#123; result.push(right.shift()); &#125; return result;&#125; 6.堆排序思想：堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列一般用数组来表示堆，i结点的父结点下标为(i-1)/2，它的左右子结点下标分别为2i+1和2*i+2。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function heapSort(array) &#123; // 交换函数 function swap(array, i, j) &#123; var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; // 最大堆调整 function maxHeapify(array, index, heapSize) &#123; var iMax, iLeft, iRight; while (true) &#123; iMax = index; iLeft = 2 * index + 1; iRight = 2 * (index + 1); // 以下两个if语句是找到左右孩子和父结点中最大值的索引 if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; //如果父结点小于左孩子，则将子结点的索引赋给iMax &#125; if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; // 如果索引为iMax的元素小于右孩子，则孩子中最大的是右孩子 &#125; // 如果最大值不是父结点，则交换父结点与孩子结点 if (iMax != index) &#123; swap(array, iMax, index); index = iMax;//递归父亲结点 &#125; else &#123; break; &#125; &#125; &#125; // 建立最大堆 function buildMaxHeap(array) &#123; var i, iParent = Math.floor(array.length / 2) - 1; // 从最下层有孩子的结点开始，遍历每个有孩子的结点 for (i = iParent; i &gt;= 0; i--) &#123; maxHeapify(array, i, array.length); &#125; &#125; // 排序 function sort(array) &#123; buildMaxHeap(array); /* 建立好最大堆之后 1.将第一个元素和最后一个元素交换位置，则最大值就放在数组的最后 2.小值跑到根节点，再重新调整最大堆，并将堆的长度减1 */ for (var i = array.length - 1; i &gt; 0; i--) &#123; swap(array, 0, i); maxHeapify(array, 0, i); &#125; return array; &#125; return sort(array);&#125; 时间复杂度 排序方法 平均情况 最好情况 最坏情况 稳定性 冒泡排序 O(n2) O(n) O(n2) 稳定 选择排序 O(n2) O(n2) O(n2) 稳定 插入排序 O(n2) O(n) O(n2) 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 快速排序 O(nlogn) O(nlogn) O(n2) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) 稳定 可参考http://www.cnblogs.com/dushao/p/6004883.html]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
