<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript-从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)]]></title>
    <url>%2F2017%2F08%2F10%2Fjavascript-howtoshowhtml%2F</url>
    <content type="text"><![CDATA[从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)记忆：输URL、查缓存、解析URL、HTTP请求报文、获取IP、建立TCP连接、发送请求、解析请求、缓存是否新鲜304、返回响应报文、关闭TCP、浏览器检查状态码、缓存资源、解码、解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本。 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤1.如果资源未缓存，发起新请求2.如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。3.检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：■ HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期■ HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下：1.浏览器缓存2.本机缓存3.hosts文件4.路由器缓存5.ISP DNS缓存6.DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接。该握手包括一个同步报文,一个同步-应答报文和一个应答报文,这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信,而后服务器应答并接受客户端的请求,最后由客户端发出该请求已经被接受的报文。1.TCP链接建立后发送HTTP请求2.服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序3.服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码4.处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作5.服务器将响应报文通过TCP连接发送回浏览器6.浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：1.主动方发送Fin=1， Ack=Z， Seq= X报文2.被动方发送ACK=X+1， Seq=Z报文3.被动方发送Fin=1， ACK=X， Seq=Y报文4.主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树：1.Tokenizing：根据HTML规范将字符流解析为标记2.Lexing：词法分析将标记转换为对象并定义属性和规则3.DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树（CSS对象模型）：1.Tokenizing：字符流转换为标记流2.Node：根据标记创建节点3.CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树:1.从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none2.对每一个可见节点，找到恰当的CSSOM规则并应用3.发布可视节点的内容和计算样式 js解析如下：1.浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading2.HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容3.当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素4.当文档完成解析，document.readState变成interactive5.所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()6.浏览器在Document对象上触发DOMContentLoaded事件7.此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面）]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>浏览器地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-跨域]]></title>
    <url>%2F2017%2F08%2F09%2Fjavascript-cross-domain%2F</url>
    <content type="text"><![CDATA[javascript的同源策略何为同源URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。 同源策略的含义脚本只能读取和所属文档来源相同的窗口和文档的属性。 为什么要有同源限制？我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手。 跨域只要协议、域名、端口有任何一个不同，都被当作是不同的域。 解决跨域的方法 1. 跨域资源共享(CORS)定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。 基本思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败服务器端对于CORS的支持，主要就是通过设置 12345&lt;script type="text/javascript"&gt; var xhr = new XMLHttpRequest(); xhr.open("￼GET", "/trigkit4",true); xhr.send();&lt;/script&gt; 上面是使用了相对路径，如果用CORS，则代码如下12345&lt;script type="text/javascript"&gt; var xhr = new XMLHttpRequest(); xhr.open("￼GET", "http://segmentfault.com/u/trigkit4/",true); xhr.send();&lt;/script&gt; 把相对路径换成了其他域的绝对路径，也就是要跨哟访问的接口地址。Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 2. 通过jsonp跨域jsonp也叫填充式JSON,是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON。 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。JSONP通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求，格式要求严格。JSONP由两部分组成：回调函数和数据。回调函数是当响应来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的 123456&lt;script type="text/javascript"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt; js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。 优点:它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 缺点：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 CORS与JSONP对比CORS与JSONP相比，无疑更为先进、方便和可靠。 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS。 3. 通过修改document.domain来跨子域将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域主域相同的使用document.domain。修改document.domain的方法只适用于不同子域的框架间的交互。 4. 使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。 5. 使用HTML5的window.postMessage方法跨域window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。 借鉴了https://segmentfault.com/a/1190000000718840]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>同源</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-内存泄漏]]></title>
    <url>%2F2017%2F08%2F09%2Fjavascript-MemoryLeak%2F</url>
    <content type="text"><![CDATA[什么叫内存泄漏不再用到的内存，没有及时释放，就叫做内存泄漏。 哪些操作会造成内存泄漏？ setTimeout 的第一个参数使用字符串而非函数的话,会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时,就会产生一个循环） 全局变量引起的内存泄漏解决办法： 使用严格模式’use strict’ DOM清空或删除，事件未清除导致的内存泄露 子元素存在引用引起的内存泄漏 被遗忘的计时器或回调函数解决办法：removeEventListener()，现状的浏览器可以正确检测和处理循环引用。 javascript垃圾回收方法 标记清除（mark and sweep）这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting)在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-同步与异步(Ajax，promise)]]></title>
    <url>%2F2017%2F08%2F08%2Fjavascript-synchronization-asynchronism%2F</url>
    <content type="text"><![CDATA[同步代码依次执行。脚本会停留并等待服务器发送回复然后再继续。 异步脚本允许页面继续其进程并处理可能的回复 setTimeout()与setInterval()setTimeout和setInterval可以改变一个队列函数的执行顺序. AjaxAjax 是异步Javascript和XML，用于在Web页面中实现异步数据交互 Ajax优点：（1）使得页面不重载全部内容的情况下加载局部内容，降低数据传输量（2）避免用户不断刷新或者跳转页面，提高用户体验 Ajax过程(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.(3)设置响应HTTP请求状态变化的函数.(4)发送HTTP请求.(5)获取异步调用返回的数据.(6)使用JavaScript和DOM实现局部刷新. Ajax原生js代码123456789101112131415function loadXMLDoc(url) &#123; var xmlhttp; // 1.创建XMLHttpRequest对象 if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp = new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; document.getElementById('p1').innerHTML = xmlhttp.responseText; &#125; &#125; xmlhttp.open("GET", url, true); xmlhttp.send();&#125; Ajax方法1.open(method,url,async) 规定请求类型、URL以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） 2.send(string)将请求发送到服务器。string：仅用于 POST 请求 Ajax请求中的get方式和post方式与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 Get是通过地址栏来传值，而Post是通过提交表单来传值。 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据。setRequestHeader(header,value)向请求添加 HTTP 头。header: 规定头的名称value: 规定头的值 XMLHttpRequest响应 responseText获得字符串形式的响应数据。 responseXML获得XML形式的响应数据。 XMLHttpRequest.onreadystatechange事件每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status 200:”OK” 404:未找到页面 promisepromise定义ES6 原生提供了 Promise 对象。所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作）.Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 promise的特点（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Fulfilled（已成功）和Rejected（已失败）。（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Fulfiled和从Pending变为Rejected。 promise对象的使用promise的构造函数1234567var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 promise实例的then()方法12345promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 promise对象实现Ajax操作的例子1234567891011121314151617181920212223242526272829var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;);]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Ajax</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-线程与进程]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-thread-process%2F</url>
    <content type="text"><![CDATA[一个程序至少有一个进程,一个进程至少有一个线程. 进程（process）是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为一些功能单元。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-正则表达式]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-RegularExpression%2F</url>
    <content type="text"><![CDATA[用正则表达式验证邮箱格式123456789function(emailAddress) &#123; var str = '^[A-Za-z\d]+([-_.][A-Za-z\d]+)*@([A-Za-z\d]+[-.])+[A-Za-z\d]&#123;2,4&#125;'; var re = new RegExp(str); //创建正则表达式对象 if(str.test(emailAddress)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 正则表达式符号^ 匹配一个输入或一行的开头，/^a/匹配”an A”，而不匹配”An a”$ 匹配一个输入或一行的结尾，/a$/匹配”An a”，而不匹配”an A”(x) 匹配x保存x在名为$1…$9的变量中x|y 匹配x或y{n} 精确匹配n次{n,} 匹配n次以上{n,m} 匹配n-m次[xyz] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符)[^xyz] 不匹配这个集合中的任何一个字符\w 匹配一个可以组成单词的字符，相当于[a-zA-Z0-9]，匹配大小写字母和数字 量词* 匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa+ 匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa? 匹配前面元字符0次或1次，/ba？/将匹配b,ba RegExp对象的方法test():检索字符串中指定的值。返回 true 或 false。exec()检索字符串中指定的值。返回找到的值，并确定其位置。 用正则表达式验证URL1^((https|http|ftp|rtsp|mms)?:\/\/)+[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&amp;_~`@[\]\':+!]*([^&lt;&gt;\"\"])*]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-setTimeOut()与setInterval()]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-setTimeOut-setInterval%2F</url>
    <content type="text"><![CDATA[Javascript用来处理延时和定时任务的setTimeOut和setInterval函数应用非常广泛，它们都用来处理延时和定时任务，比如打开网页一段时间后弹出一个登录框，页面每隔一段时间发送异步请求获取最新数据等等。 setTimeOut() setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式 setTimeout()只执行一次 第一个参数是要执行的code或句柄，第二个是延迟的毫秒数。 用法 1var timeoutID = window.setTimeout(func, [delay, param1, param2, ...]); var timeoutID = window.setTimeout(code, [delay]); clearTimeOut()函数用来清除定时器 实例 12345for(var i=1;i&lt;=3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0);&#125;; 输出4，4，4原因：Javascript事件处理器在线程空闲之前不会运行。那么问题来了，如何让上述代码输出1 2 3？12345for(var i=1;i&lt;=3;i++)&#123; setTimeout((function(a)&#123; //改成立即执行函数 console.log(a); &#125;)(i),0);&#125;; setInterval() setInterval()是在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval()把它清除 第一个参数是要执行的code或句柄，第二个是延迟的毫秒数。 写一个递归，每隔5秒调用自身，一共100次。12345678var counter = 0;var timer = setInterval(function() &#123; alert('test'); counter++; if(counter == 100) &#123; clearInterval(timer); &#125;&#125;,5000);]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>setTimeout()</tag>
        <tag>setInterval()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-基本数据类型]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-DataType%2F</url>
    <content type="text"><![CDATA[六种基本数据类型 undefined: 一个未初始化的变量的值为undefined; 一个没有传入实参的形参变量的值为undefined; 如果一个函数什么都不返回,则该函数默认返回undefined; null: 没有对象被呈现 string: boolean: number: sysbol(ES6): null与undefined的不同点 null是一个字面量（而不是全局对象的一个属性,undefined 是）; null是一个表示”无”的对象, Number(null) == 0；undefined是一个表示”无”的原始值, Number(undefined) == NaN。 当声明的变量还未被初始化时,变量的默认值为undefined。 null用来表示尚未存在的对象,常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义。典型用法是： （1）变量被声明了,但没有赋值时,就等于undefined。（2） 调用函数时,应该提供的参数没有提供,该参数等于undefined。 （3）函数没有返回值时,默认返回undefined。 （4）对象没有赋值的属性,该属性的值为undefined。 null表示”没有对象”,即该处不应该有值。典型用法是： （1） 作为函数的参数,表示该函数的参数不是对象。 （2） 作为对象原型链的终点。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>undefined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-localsearch本地搜索]]></title>
    <url>%2F2017%2F08%2F07%2Fhexo-localsearch%2F</url>
    <content type="text"><![CDATA[在git bash上输入npm install hexo-generate-search –save 再安装npm install hexo-generate-searchdb –save 在主题目录下的配置文件_config.yml中修改1234567local_search: enable: true //改为true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>本地搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-事件流，事件代理]]></title>
    <url>%2F2017%2F08%2F07%2Fjavascript-EventFlow%2F</url>
    <content type="text"><![CDATA[事件流事件流模型冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="outer"&gt; &lt;div id="inner"&gt; Click me! &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在冒泡型事件流click事件的传播顺序为：inner-&gt;outer-&gt;body-&gt;html-&gt;document 在捕获型事件流click事件的传播顺序为：document-&gt;html-&gt;body-&gt;outer-&gt;inner DOM事件流DOM事件流采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。 事件捕获阶段：实际目标在捕获阶段不会接收事件。也就是在捕获阶段。上图中为1~3. 处于目标阶段：事件上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。 冒泡阶段：事件又传播回文档。 在DOM事件流中，实际的目标inner在捕获阶段不会接受到事件。这意味着在捕获阶段，事件到outer就停止了，下一个阶段是“处于目标”阶段，于是事件在inner 上发生，并在事件处理中被看成是冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 DOM2级事件定义了两个方法用于处理置顶和删除事件处理程序的操作addEventListener()和removeEventListener()，所有DOM节点都包含这两个方法，并且它们都接受3个参数：要处理的事件名，作为事件处理的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序，反之则是在事件冒泡阶段处理程序。DOM2级方法添加事件处理程序的好处是可以添加多个事件处理程序，会按照添加顺序被处理（无论是捕获还是冒泡）。而IE不同的它有自己的方法attachEvent()和detachEvent,这两个接受相同的两个参数：事件处理程序名称和事件处理程序函数。 DOM2级事件定义了两个方法用于处理置顶和删除事件处理程序的操作addEventListener()和removeEventListener()，所有DOM节点都包含这两个方法，并且它们都接受3个参数：要处理的事件名，作为事件处理的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序，反之则是在事件冒泡阶段处理程序。DOM2级方法添加事件处理程序的好处是可以添加多个事件处理程序，会按照添加顺序被处理（无论是捕获还是冒泡）。 IE的事件流IE没有提供对事件捕获的支持，所以IE跟标准浏览器对DOM事件流实现不一样。而IE不同的它有自己的方法attachEvent()和detachEvent,这两个接受相同的两个参数：事件处理程序名称和事件处理程序函数。 添加和删除事件监听器：w3c： addEventListener/ removeEventListener()IE: attachEvent()/ detachEvent() 事件监听：IE事件监听器使用全局的Event对象，而w3c将event对象作为参数传递给监听器123function handler（event）&#123; event = event || window.event;&#125; 阻止冒泡：IE： e.cancelBubble=true;w3c：e.stopPropagation(); attachEvent 与addEventListener区别一、适应的浏览器版本不同二、attachEvent中的事件带on，而addEventListener中的事件不带on三、参数的个数不同attachEvent()，只有冒泡；addEventListener(事件名称,接收事件处理的函数,bool值) 默认为false，事件句柄在冒泡阶段执行，true在捕获阶段。 event.stopPropagation(); 支持FF=&gt; 停止传播event.cancelBubble = true; 支持IE =&gt; 取消冒泡 自动执行点击事件，兼容IE12345678910111213141516171819202122window.onload = function() &#123; var btn = document.getElementById('my-btn'); var handler = function() &#123; alert(this.tagName); &#125; if (btn.addEventListener) &#123; // 调用的处理程序使用事件目标作为它们的this值 // 此处也可以传递e事件：handler(e); e.target.tagName btn.addEventListener("click", handler, false); &#125; else if (btn.attachEvent) &#123; // 注册的处理程序作为函数调用，它们的this值是全局（window）对象 // 此处也可以传递e事件：handler(e); e.srcElement.tagName btn.attachEvent("onclick", handler.call(btn)); &#125; if (document.all) &#123; btn.click(); &#125; else &#123; var evt = document.createEvent("MouseEvents"); evt.initEvent("click", true, true); btn.dispatchEvent(evt); &#125;;&#125; 事件代理事件代理的原理事件代理的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。 传统事件处理做法是为每个元素添加事件处理器。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; (function()&#123; var colorList=document.getElementById("color-list"); var colors=colorList.getElementsByTagName("li"); for(var i=0;i&lt;colors.length;i++) &#123; colors[i].addEventListener('click',showColor,false); &#125;; function showColor(e) &#123; e=e||window.event; var targetElement=e.target||e.srcElement; alert(targetElement.innerHTML); &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt; 事件代理的处理方式是： 12345678910111213141516171819202122232425&lt;body&gt; &lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; (function()&#123; var colorList=document.getElementById("color-list"); colorList.addEventListener('click',showColor,false); function showColor(e) &#123; e=e||window.event; var targetElement=e.target||e.srcElement; if(targetElement.nodeName.toLowerCase()==="li")&#123; alert(targetElement.innerHTML); &#125; &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt; 事件代理的好处 将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。 DOM更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。 事件代理的问题事件代理同时绑定了li和span，当点击span的时候，li和span都会冒泡。1234567891011&lt;li&gt;&lt;span&gt;li中的span的内容&lt;/span&gt;&lt;/li&gt;&lt;script&gt; $(document).on('click', 'li', function(e)&#123; alert('li li'); &#125;); $(document).on('click', 'span', function(e)&#123; alert('li span'); &#125;)&lt;/script&gt; 解决办法： span的事件处理程序中阻止冒泡 1234$(document).on('click', 'span', function(e)&#123; alert('li span'); e.stopPropagation();&#125;) li的事件处理程序中检测target元素 1234567$(document).on('click', 'li', function (e) &#123; if (e.target.nodeName == 'SPAN') &#123; e.stopPropagation(); return; &#125; alert('li li');&#125;);]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>事件流</tag>
        <tag>事件代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-数组-字符串方法]]></title>
    <url>%2F2017%2F08%2F06%2Fjavascript-Array-String%2F</url>
    <content type="text"><![CDATA[Array数组 concat()用途 用于连接两个或多个数组，返回被连接的数组。 语法 arrayObject.concat(arrayX,arrayY) 实例12var arr = ['A', 'B', 'C'];var arr2 = [1,2,3]; arr.concat(arr2);//['A','B','C','D',1,2,3],arr并没有被修改 pop()用途 删除并返回最后一个元素 语法 arrayObject.pop() 实例12var arr = ['A', 'B', 'C'];arr.pop();//arr=['A','B'] push()用途 向数组尾部添加一个或更多元素，返回新的长度。 语法 arrayObject.push(elment1,element2…) 实例12var arr = ['A', 'B', 'C'];arr.push('J','K');//['A','B','C','J','K'] shift()用途 删除并返回数组的第一个元素 实例12var arr = ['A', 'B', 'C'];arr.shift();//['B','C'] slice()用途 截取数组的部分长度，然后返回新的数组 实例123arr.slice(0,2);//从开始索引0开始，到结束索引结束，但不包括结束索引，['A','B']arr.slice(2);//从开始到结束，['D'] splice()用途 向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组 语法 arrayObject.splice(index,howmany,item1,item2…) 实例123456var arr = [1,2,3,4,5];arr.splice(2,0,6); // arr=[1,2,6,3,4,5]在下标为2的位置上添加，0表示添加，返回[]arr.splice(2,1,7);// arr=[1,2,7,3,4,5]在下标为2的位置上删除该元素并替换成7，1代表删除，返回[6]arr.splice(1,3); //arr=[1,4,5],返回被删除的元素[2,7,3]arr.splice(1,2,6,8);//arr=[1,6,8]，返回被删除的元素[4,5] unshift()用途 向数组头部添加一个或更多元素，并返回新的长度。 实例12var arr = [1,2,3,4,5];arr.unshift(6,7);//返回新长度3，arr=[6,7,1,2,3,4,5] indexOf()用途 搜索一个指定元素的位置 实例12var arr = [1,2,3,4,5];arr.indexOf(2); // 1 forEach()用途对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。 实例12345678910var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123; console.log(x + '|' + index + '|' + (a === arr));&#125;);// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true map()用途指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 实例12345var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item)&#123; return item*item;&#125;);console.log(arr2); //[1, 4, 9, 16, 25] String charAt()用途 返回在指定位置的字符 实例12var s = 'abcdef';s.charAt(3);// d indexOf()用途 返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。 语法 strObj.indexOf(substr[,startIndex]) 实例12var str = "ABCDECDF";str.indexOf("CD"，1); // 由1位置从左向右查找 123... 返回2 slice()用途 返回字符串片段。 语法strObj.slice(start[,end])start下标从0开始的strObj指定部分其实索引。如果start为负，将它作为length+start处理，此处length为字符串的长度。end下标从0开始的strObj指定部分结束索引。如果end为负，将它作为length+end处理，此处length为字符串的长度。 实例12var str = "ABCDEF";str.slice(2,4); //第2个参数为&lt;end的下标，返回CD split()用途 把一个字符串分割成字符串数组 语法stringObject.split(separator,howmany) 实例12var str="How are you doing today?"console.log(str.split(" ")); // How,are,you,doing,today? substr()用途抽取从 start 下标开始的指定数目的字符 语法stringObject.substr(start,length) 实例12var str = "hello world";console.log(str.substr(3,4));// lo w substring()用途提取字符串中介于两个指定下标之间的字符。 语法stringObject.substring(start,stop) 实例12var str = "hello world";console.log(str.substring(3,5));// lo]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-New关键字]]></title>
    <url>%2F2017%2F08%2F06%2FJavascript-New%2F</url>
    <content type="text"><![CDATA[new操作符具体干了什么呢？12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;;// (1) o.__proto__=Person.prototype; //(2)原型继承 Person.call(o,name);// (3) return o;// (4)&#125;var personB=person("xl");console.log(personB.name); // 输出 xl (1)新建一个空对象o；(2)设置原型链，将o的__proto__指向Person.prototype,完成对Person的原型对象的属性和方法的继承；(3)让Person中的this指向o；(4)返回对象o。此时调用person()函数就相当于new Person()。]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-This关键字]]></title>
    <url>%2F2017%2F08%2F06%2FJavascript-This%2F</url>
    <content type="text"><![CDATA[谁调用这样函数或方法，this关键字就指向谁。在JS中，函数调用的方式有 普通函数调用 作为方法来调用 作为构造函数调用 使用apply/call方法来调用 Function.prototype.bind()方法 es6箭头函数 普通函数调用 1234567function person()&#123; this.name="xl"; console.log(this); console.log(this.name);&#125;person(); //输出 window xl 相当于person()作为全局变量window的一个方法来调用，相当于window.person()，所以this志向window. 作为方法来调用 1234567891011var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xlvar showNameA=person.showName;showNameA(); //输出 XL 1.这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出”Xl”.2.这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window. 作为构造函数来调用 12345678910function Person(name)&#123; this.name=name;&#125;var personA=Person("xl");console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xlvar personB=new Person("xl");console.log(personB.name);// 输出 xl//这部分代码的解释见下 1.上面代码没有进行new操作，相当于window对象调用Person(“xl”)方法，那么this指向window对象，并进行赋值操作window.name=”xl”. new操作符12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;; o.__proto__=Person.prototype; //原型继承 Person.call(o,name); return o;&#125;var personB=person("xl");console.log(personB.name); // 输出 xl 1.首先在person里创建空对象o，将o的__proto__指向Person.prototype,完成对Person的原型对象的属性和方法的继承；2.Person.call(o,name)表示将Person对象中的this指向o，即o.name=name;3.返回对象o。 call/apply方法的调用 call/apply方法最大的作用就是改变this的指向。Obj.method.apply(AnotherObj,arguments);123456789var name="XL";var Person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;Person.showName.call(); //输出 "XL"Person.showName();// 输出“Xl” call()不带参数是指向window，若带参数，this指向第一个参数。 Function.prototype.bind()方法 1234567891011var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;,50) &#125;&#125;var person=new Person("xl");person.sayName() //输出 “my name is XL”; setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL1234567891011var name="XL"; function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;.bind(this),50) //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象 &#125; &#125; var person=new Person("xl"); person.sayName(); //输出 “my name is xl”; 这里setTimeout(function(){console.log(this.name)}.bind(this),50);,匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向的Person,而非window,因此最后的输出为”my name is xl”而不是”my name is XL” setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined Eval()函数 该函数执行时，this绑定到当前作用域的对象上。123456789101112var name="XL";var person=&#123; name:"xl", showName:function()&#123; eval("console.log(this.name)"); &#125;&#125;person.showName(); //输出 "xl"var a=person.showName;a(); //输出 "XL" es6箭头函数 箭头函数的 this 始终指向函数定义时的 this，而非执行时。12345678910var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(() =&gt; &#123; this.func() &#125;, 100); // this指向o &#125;&#125;;o.test();// 1 借鉴了[https://segmentfault.com/a/1190000003046071]]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-继承]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Inherit%2F</url>
    <content type="text"><![CDATA[概述 继承方式原型链继承 思想为了让子类继承父类的属性，首先需要定义一个构造函数。然后将父类的新实例赋值给构造函数的原型对象。 代码示例12345678910111213function Parent()&#123; this.name = 'mike'; &#125; function Child()&#123; this.age = 12; &#125; Child.prototype = new Parent();//Child继承Parent，通过原型，形成链条，核心代码 var test = new Child(); alert(test.age); alert(test.name);//得到被继承的属性 alert(test instanceof Child); //确定原型对象和实例的关系。 特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例； 父类新增原型方法/属性，子类能访问到； 简单，易于实现。 缺点 想为子类新增方法和属性，必须在 new Parent()这样的语句之后执行，不能放到构造函数中； 无法实现多继承； 来自原型对象的引用属性是所有实例共享的；（致命） 创建子类实例时，无法向父类构造函数传参。（致命） 构造继承 思想在子类构造函数的内部调用超类的构造函数，通过call()和apply()方法可以在创建的对象上执行构造函数。（没用到原型） 代码示例1234567891011function SuperType() &#123; this.colors = ["red","blue","green"];&#125;function SubType() &#123; SuperType.call(this);//继承了SuperType，核心代码&#125;var instance1 = new SubType();instance1.colors.push("black");console.log(instance1.colors);//"red","blue","green","black"var instance2 = new SubType();console.log(instance2.colors);//"red","blue","green" 特点 解决了原型链继承中，子类实例共享父类引用的属性问题； 创建子类型时，可以向父类传递参数； 可以实现多继承 缺点 实例并不是父类的实例，只是子类的实例； 只能继承父类实例的属性和方法，不能继承原型对象的属性和方法；（没有用到原型链） 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能。（致命，原型链可复用） 组合继承（最常用） 思想使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。通过Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Sub.prototype = new Super();继承父类函数，实现函数复用。 代码示例1234567891011121314151617181920212223242526function SuperType(name) &#123; this.name = name; this.colors = ["red","blue","green"];&#125;SuperType.prototype.sayName = function() &#123;co nsole.log(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this,name);//使用构造函数继承属性，核心代码 this.age = age;&#125;//继承方法SubType.prototype = new SuperType();// 使用原型链继承原型对象的SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;var instance1 = new SubType("EvanChen",18);instance1.colors.push("black");console.log(instance1.colors);//"red","blue","green","black"instance1.sayName();//"EvanChen"instance1.sayAge();//18var instance2 = new SubType("EvanChen666",20);console.log(instance2.colors);//"red","blue","green"instance2.sayName();//"EvanChen666"instance2.sayAge();//20 特点 不存在引用属性共享问题 可传参给父对象 函数可复用 缺点 父类的构造函数被引用了两次 原型式继承 思想 继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式。 代码示例1234567891011121314151617181920212223// 核心模块function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var box = &#123; name : 'trigkit4', arr : ['brother','sister','baba']&#125;;var b1 = obj(box);alert(b1.name);//trigkit4b1.name = 'mike';alert(b1.name);//mikealert(b1.arr);//brother,sister,babab1.arr.push('parents');alert(b1.arr);//brother,sister,baba,parentsvar b2 = obj(box);alert(b2.name);//trigkit4alert(b2.arr);//brother,sister,baba,parents 特点从已有对象衍生新对象不需要创建自定义类型 缺点 原型引用属性会被所有实例共享，因为是用整个父类对象来充当子类的原型对象。 无法实现代码复用 寄生式继承 思想创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。创建新对象-&gt;增强-&gt;返回该对象 寄生组合式继承（最完美） 思想通过寄生方式，去掉父类的实例属性，这样，在调用两次父类的构造函数时，就不会初始化两次实例方法/属性，避免组合继承的缺点。 代码示例123456789101112131415161718192021222324252627282930313233343536373839// 原型式继承代码function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; // 创建对象-&gt;增强对象-&gt;返回对象，核心代码 function create(parent,child)&#123; var f = obj(parent.prototype);//创建对象 f.constructor = child;//增强对象 child.prototype = f; return f; &#125; function Parent(name)&#123; this.name = name; this.arr = ['brother','sister','parents']; &#125; Parent.prototype.run = function () &#123; return this.name; &#125;; function Child(name,age)&#123; Parent.call(this,name);//构造函数 this.age =age; &#125; create(Parent,Child);//通过这里实现继承 var test = new Child('trigkit4',21); test.arr.push('nephew'); console.log(test.arr);//["brother", "sister", "parents", "nephew"] console.log(test.age);// 21 console.log(test.run());//trigkit4 var test2 = new Child('jack',22); console.log(test2.age);// 22 console.log(test2.arr);//["brother", "sister", "parents"] 特点完美]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-原型链]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Prototype%2F</url>
    <content type="text"><![CDATA[普通对象与函数对象 凡是通过new Function()创建的对象都是函数对象，其他的都是普通对象。 构造函数 实例的属性（constructor）指向构造函数。 原型对象 函数对象(构造函数)都有prototype属性，指向函数的原型对象。每个对象都有__proto__属性，但只有函数对象才有prototype。 在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）属性，这个属性指向prototype属性所在的函数（Person） 12Person.prototype.constructor == Person;person1.constructor == Person; 原型对象（Person.prototype）是构造函数（Person）的一个实例。原型对象是用来继承的。 __proto__ 对象都有__proto__的内置属性，指向创建它的构造函数的原型对象。person1.__proto__== Person.protoype1234567891011var b = new Array();b.constructor === Array;b.__proto__ === Array.prototype;var c = new Date();c.constructor === Date;c.__proto__ === Date.prototype;var d = new Function();d.constructor === Function;d.__proto__ === Function.prototype; 所有函数对象的__proto__都指向Function.prototype，它是一个空函数。12345678910111213141516171819202122232425262728Number.__proto__ === Function.prototype // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype // trueError.constructor == Function //trueDate.__proto__ === Function.prototype // trueDate.constructor == Function //true Math和JSON无需new12345Math.__proto__ === Object.prototype // trueMath.construrctor == Object // trueJSON.__proto__ === Object.prototype // trueJSON.construrctor == Object //true 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind。Function.prototype是唯一一个typeof XXX.prototye为function的prototype，其它的构造器的prototype都是object1Object.prototype.__proto__ === null // true 原型链的基本思路 利用原型让引用类型继承另一个引用类型的属性和方法。每隔构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（construrctor），而实例对象都包含一个指向源性对象的内部指针(__proto__)，如果让原型对象等于另一个类型的实例，此时的原型对象将包含另一个原型的指针(__proto__)，另一个原型也包含着一个指向另一个构造函数的指针（construrctor），构成了实例和原型的链条。 总结 所有函数对象的__proto__都指向Function.prototype，是一个空函数。 所有对象的__proto__都指向其构造函数的prototype。 每个对象都有construrctor属性，指向构造函数。 person1.__proto__==Person.protype==person1.construrctor.prototype Object.prototype.__proto__ == null 原型链存在于实例和构造函数的原型对象之间，即 person1.__proto__ == Person.prototype 本文借鉴了[http://www.jianshu.com/p/dee9f8b14771]，http://blog.csdn.net/sinat_21274091/article/details/52741788]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-作用域链]]></title>
    <url>%2F2017%2F08%2F05%2Fjavascript-Scope%2F</url>
    <content type="text"><![CDATA[定义 作用域：是一个“地盘”，一个抽象概念，其中没有变量，要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。作用域中变量的值是执行过程中产生的确定的，而作用域是在函数创建时就确定了。 要查询一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会又冲突。 函数作用域1234567var scope="global"; function t()&#123; console.log(scope); // undefined var scope="local" console.log(scope); // "local"&#125; t(); javascript没有块级作用域，有函数作用域函数作用域:变量在声明它们的函数体以及这个函数嵌套的任意函数体内都是有定义的。javascript没有块级作用域，如下：123456var name="global"; if(true)&#123; var name="local"; console.log(name); // "local" &#125; console.log(name); // "local" 作用域链 作用域链：作用域链的创建是在执行上下文生命周期的创建时建立的。作用域链是当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 简述作用域链 引入一大段话来解释：每一段js代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码中“作用域中”的变量。当js需要查找变量x的值的时候（这个过程称为变量解析（variable resolution）），它会从链的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中没有名为x的属性，js会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。 作用域链举例：在js最顶层代码中（也就是不包括任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域上至少有三个对象。 作用域链创建规则：当定义一个函数时（注意，是定义的时候就开始了），它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来储存它的参数或局部变量，并将这个对象添加保存至那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来说，情况又有所变化：每次调用外部函数的时候，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都要微妙的差别—在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。 可参考[http://blog.csdn.net/yueguanghaidao/article/details/9568071],]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-闭包]]></title>
    <url>%2F2017%2F08%2F04%2FJavascript-Closure%2F</url>
    <content type="text"><![CDATA[定义闭包：有权访问另一个函数作用域中的变量的函数。 在javascript语言中，只有函数内部的子函数才能读取局部变量，所以闭包也可以理解为“定义在一个函数内部的函数”。 闭包是连接函数内部和外部的联系。 javascript的链式作用域结构，子对象会一级一级地向上寻找所有父对象的变量。所以父对象的所有变量对子对象是可见的。 闭包实例将内部函数作为返回值，就可访问函数内的变量。123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 闭包的用处 可以读取函数内部的变量； 让函数内部的变量的值保持在内存中。 123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点 由于闭包会使得函数中的变量被保存在内存中，内存消耗很大，不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是在退出函数之前，将不适用的局部变量全部删除。 闭包会在父函数外部改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，不要随便改变父函数内部变量的值。闭包的缺点闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄漏。 可参考[http://www.cnblogs.com/wangfupeng1988/p/3994065.html],[http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html]]]></content>
      <categories>
        <category>javascript语法</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构(javascrit)]]></title>
    <url>%2F2017%2F08%2F02%2FData_Structure%2F</url>
    <content type="text"><![CDATA[线性表1.线性表的定义 零个或多个数据元素的有限序列。 2.线性表的分类 线性表的顺序存储结构：指的是用一段地址连续的存储单元一次存储线性表的数据元素。 线性表的链式存储结构：地址不一定连续来存储线性表的数据元素。 3.线性表的操作3.1 顺序存储3.1.1 查找元素 时间复杂度O(1) 3.1.2 插入操作思路 如果插入位置不合理，抛出异常； 如果线性表长度大于等于数组长度，则抛出异常； 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置； 将要插入元素填入位置i处； 表长加1。时间复杂度O(1). 3.1.3 删除操作思路 如果删除位置不合理，抛出异常； 取出删除元素； 从删除元素的位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置； 表长减1。时间复杂度O(1). 3.2 链式存储3.2.1 查找元素思路 声明一个结点p指向链表第一个结点； 遍历链表，指针p向后移动； 若到链表结尾p为空，则说明第i个元素不存在； 否则查找成果，返回p结点。最好时间复杂度O(1),最坏时间复杂度O(n). 3.2.2 插入元素标准代码:12s.next = p.next;p.next = s; 3.2.3 删除元素标准代码：12q = p.next;p.next = q.next; 4.单链表结构与顺序存储结构的优缺点4.1 时间性能 查找：顺序存储结构O(1),单链表O(n) 插入和删除：顺序存储结构平均时间复杂度O(n),单链表O(1) 4.2 空间性能 顺序存储结构需要预分配存储空间。单链表不需要分配存储空间。 5.单链表的分类5.1 静态链表 用数组描述的链表叫静态链表。 5.2 循环链表 将单链表中终端结点的指针由空指针改为指向头结点，头尾相连的单链表称为单循环链表。 5.3 双向链表 单循环链表增加一个指向前驱结点的指针。 插入操作 1234s.prior = p;s.next = p.next;p.next.prior = s;p.next = s; 删除操作 12p.prior.next = p.next;p.next.prior = p.prior; 栈与队列1. 定义 栈：限定仅在表尾进行插入和删除操作的线性表（后进先出） 队列：只允许在一端进行插入操作，而在另一端进行删除操作的线性表（先进先出） 2.操作2.1 栈进栈push()出栈pop() 3.分类循环队列队列满的条件是(rear+1)%QueueSize == front队列长度公式是(rear-front+QueueSize)%QueueSize 树1.定义树：是n个结点的有限集 2.相关概念度：树的度是树内各结点的度的最大值。深度：树中结点的最大层次称为树的深度。 3.树的存储结构 双亲表示法data,parent 孩子表示法data,parent,firstchild-child,next 孩子兄弟表示法data,firstchild,rightsib 4.二叉树4.1 特点 每个结点最多有两颗子树 左子树和右子树是有顺序的。 4.2 分类 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 二叉树的性质 在二叉树的第i层至多有2i-1个结点。 深度为k的二叉树至多有2k-1个结点。 对任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1。(n=n0+n1+n2,分支数总数等于结点总数减1，分支总数=n-1=n1+2n2) 具有n个结点的完全二叉树的深度为[log2n]+1. 如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i有：1.如果i=1,则结点i是二叉树的根，无双亲；如果i&gt;1,则其双亲是结点[i/2].2.如果2i&gt;n,则结点i无左孩子；否则其左孩子是结点2i。3.如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1。 4.3 二叉树的存储结构二叉链表： lchild,data,rchild 4.4 基本操作4.4.1 插入1234567891011121314151617181920212223242526272829303132333435363738/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125; function BST() &#123; this.root = null; this.insert = insert; this.inOrder = inOrder;&#125;*/ function insert(data) &#123; let node = new TreeNode(data,null,null); //插入根结点 if(this.root == null) &#123; this,root = n; &#125; else &#123; let current = this.root; let parent; while(current) &#123; parent = current; if(data&lt;current.data) &#123; current = current.left; if(current == null) &#123; parent.left = node; break; &#125; &#125; else &#123; current = current.right; if(current == null) &#123; parent.right = node; break; &#125; &#125; &#125; &#125; &#125; 4.4.2 查找最小值（最大值）1234567function getMin() &#123; let current = this.root; while(!(current.left == null)) &#123; current = current.left; &#125; return current.data;&#125; 4.4.3 查找指定值12345678910111213function find(data) &#123; let current = this.root; while(current != null) &#123; if(current.data == data) &#123; return current; &#125; else if (data&lt; current.data) &#123; current = current.left; &#125; else &#123; current = current.right; &#125; &#125; return null;&#125; 4.4.4 删除结点 删除结点有三种情况： 叶子结点，则父结点指向null 仅有左或右子树的结点，则原本指向它的结点就指向它的子结点 左右子树都有结点，则查找删除结点右结点上的最小值，将临时结点上的值复制到待删除结点，然后再删除临时结点。 1234567891011121314151617181920212223242526272829303132333435363738394041function remove(data) &#123; root = removeNode(this.root,data);&#125;//找到最小值function getMin(node) &#123; if (node.left == null) &#123; return node; &#125; else &#123; return getMin(node.left); &#125;&#125;function removeNode(node,data) &#123; if(node == null) &#123; return null; &#125; if(data == node.data) &#123; // 叶子结点 if(node.left == null &amp;&amp; node.right ==null) &#123; return null; &#125; //没有左子结点的结点 if(node.left == null) &#123; return node.right; &#125; if(node.right == null) &#123; return node.left; &#125; // 有2个子结点的结点 let tempNode = getMin(node.right); node.data = tempNode.data; node.right = removeNode(node.right,tempNode.data); return node; &#125; else if (data&lt;node.data) &#123; node.left = removeNode(node.left,data); return node; &#125; else &#123; node.right = removeNode(node.right,data); return node; &#125;&#125; 4.5 二叉树的遍历4.5.1 前序遍历 先访问根结点，然后前序遍历左子树，再前序遍历右子树。1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function PreOrderTraverse(node) &#123; if(!(node == null)) &#123; console.log(node.data); PreOrderTraverse(node.left); PreOrderTraverse(node.right); &#125;&#125; 4.5.2 中序遍历 先中序遍历左子树，访问根结点，再中序遍历右子树。1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function InOrderTraverse(node)&#123; if(!(node == null)) &#123; InOrderTraverse(node.left); console.log(node.show()); InOrderTraverse(node.right); &#125;&#125; 4.5.3 后序遍历 先后序遍历左右子树，再访问根结点。 1234567891011121314/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125;*/function PostOrderTraverse(node)&#123; if(!(node == null)) &#123; PostOrderTraverse(node.left); console.log(node.show()); PostOrderTraverse(node.right); &#125;&#125; 4.5.4 层序遍历 从根结点开始访问，从上而下逐层遍历。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(javascript)]]></title>
    <url>%2F2017%2F07%2F21%2FSort-Function%2F</url>
    <content type="text"><![CDATA[二分查找法12345678910111213141516171819function binarysearch(arr, target) &#123; if(arr.length == 0) &#123; return 0; &#125; let low = 0; let high = arr.length; let mid; while(low &lt;= high) &#123; mid = Math.floor((high-low)/2); if(target == arr[mid]) &#123; return mid; &#125; else if (target &lt; arr[mid]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return 0;&#125; 冒泡排序法1234567891011121314151617181920/* 从底层开始冒泡，两两比较，小的放在前面，直到小泡泡*/function BubbleSort(arr) &#123; if (arr.length == 0) &#123; return 0; &#125; let temp = 0; for(let i = 0; i &lt; arr.length - 1; i++) &#123; // i是顶层的泡泡，标记最小的值 for(let j = arr.length - 2; j &gt;= i; j--) &#123; if(arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125; 插入排序法1234567891011121314151617181920212223/*1.默认第一个已经排好序2.依次将接下来的数与数组里的每个元素进行比较，若比前一个小*/function InsertSort(arr) &#123; if (arr.length == 0) &#123; return 0; &#125; let temp = 0; // 存放当前元素 for(let i = 1; i &lt; arr.length; i++) &#123; if(arr[i] &lt; arr[i-1]) &#123; temp = arr[i]; let pre = i - 1; while(pre &gt;= 0 &amp;&amp; temp &lt; arr[pre]) &#123; arr[pre+1] = arr[pre]; pre--; &#125; arr[pre+1] = temp; &#125; &#125; return arr;&#125; 快速排序基本思想: 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。12345678910111213141516171819202122232425262728293031323334/** 它是由冒泡排序改进而来的。在待排序的n个记录中任取一个记录，把该记录放在合适的位置后，* 数据序列被此记录划分为两部分。所有关键字比该记录关键字小的记录放在前一部分，所有比它大的记录放置在后一部分，并把该记录排在这两部分的中间。*/ //交换函数function swap(arr,i,j) &#123; const temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;//分区函数function partition(arr, left , right) &#123; let pivot = left; //基准 let index = pivot + 1; for(let i = index; i&lt;=right;i++) &#123; if(arr[i]&lt;arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr,pivot,index-1); return index-1;&#125;// 快速排序算法function quickSort(arr, left, right) &#123; const len = arr.length; let partitionIndex = 0; if(left&lt;right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1,right); &#125; return arr;&#125; 归并排序思想：两两进行比较，再归并。 归并排序的性能不受输入数据的影响，始终是O(nlogn)，代价是需要额外空间。123456789101112131415161718192021222324252627function mergeSort(arr) &#123; const len = arr.length; if(len&lt;2) &#123; return arr; &#125; let middle = Math.floor(len/2); let left = arr.slice(0,middle); let right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left,right) &#123; let result = [] while(left.length&gt;0 &amp;&amp; right.length&gt;0) &#123; if(left[0] &lt; right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) &#123; result.push(left.shift()); &#125; while(right.length) &#123; result.push(right.shift()); &#125; return result;&#125; 时间复杂度 排序方法 平均情况 最好情况 最坏情况 稳定性 冒泡排序 O(n2) O(n) O(n2) 稳定 直接插入排序 O(n2) O(n) O(n2) 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 快速排序 O(nlogn) O(nlogn) O(n2) 不稳定 可参考http://www.cnblogs.com/dushao/p/6004883.html]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
